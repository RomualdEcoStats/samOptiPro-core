
---
title: "Optimizing Samplers in NIMBLE"
author: "Romuald H."
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  beamer_presentation:
    slide_level: 1
    theme: metropolis
    colortheme: dove
    fonttheme: professionalfonts
    includes:
      in_header: header.tex
    latex_engine: xelatex
    keep_tex: true
    pandoc_args: ["--listings"]   # ← active LaTeX listings pour le code
    incremental: false
classoption: "aspectratio=169"    # écran 16:9, moins de coupures
fontsize: 10pt                    # densité raisonnable
---

```{r load-samoptipro, include=FALSE}

path_pkg <- "~/Scorff LCM_model1/samOptiPro"

if (!requireNamespace("samOptiPro", quietly = TRUE)) {
  if (requireNamespace("devtools", quietly = TRUE) && dir.exists(path_pkg)) {
    message("Loading samOptiPro from source: ", path_pkg)
    devtools::load_all(path_pkg, quiet = TRUE)
  } else {
    stop("samOptiPro not found. Either install it or set 'path_pkg' correctly.")
  }
}
library(samOptiPro)

```

```{r setup, include=FALSE}
library(knitr)

knitr::opts_chunk$set(dev = "ragg_png",comment=NA, echo = FALSE,  cache=TRUE, message=FALSE,warning=FALSE, error=FALSE,fig.width=8,fig.height=4,bg="transparent", cache.lazy=FALSE)
set.seed(123)
ilogit <- plogis; logit <- qlogis
`%||%` <- function(x, y) if (is.null(x)) y else x

```

```{r beamer-one-figure-per-frame, include=FALSE}
`%||%` <- function(x, y) if (is.null(x)) y else x
old_plot_hook <- knitr::knit_hooks$get("plot")

knitr::opts_chunk$set(fig.show = "asis")  # imprime chaque figure dès qu'elle est produite

knitr::knit_hooks$set(plot = function(x, options) {
  # Un frame PAR image, automatiquement
  cap <- options$fig.cap %||% options$label %||% ""
  sprintf("\\begin{frame}{%s}\n\\centering\n\\includegraphics[width=\\linewidth,height=0.82\\textheight,keepaspectratio]{%s}\n\\end{frame}\n", cap, x)
})
```
#Introduction

This tutorial demonstrates how to **diagnose differentiability** and **optimize MCMC sampling strategies** in complex Bayesian state–space models using the R package **`samOptiPro`** (Hounyeme *et al.*, 2025).  
We illustrate the workflow on a simple population dynamics model, using `nimble` and `nimbleHMC` as the computational back-end.

We will:
- Build and simulate a **population growth model** with latent process and log-normal observations.
- Identify bottelenecks (Algorithmic bottelenecks or and Time bottelelnecks)
- Diagnose **non-differentiable components** (to decide whether HMC/NUTS is applicable).
- Automatically **benchmark samplers** (RW, Slice, AF_slice, HMC, NUTS) using `test_strategy_block()`.
- Assess **algorithmic (AE)** and **computational efficiency (CE)**.

All results (traceplots, diagnostics, and performance summaries) are saved under `outputs/`.

# Step 0- Load packages
```{r Load Packages}
library(coda)
library(ggplot2)
library(nimble)
library(nimbleHMC)
#Load samOptiPro

#library(samOptiPro)
```

#Step 1. Simulated Data, Initial Values and monitors

```{r Inputs Data & Monitors, echo=FALSE}
# Simulation constants
time <- 8
Const_nimble <- list(
  n        = time,
  sd_dummy = 0.05,
  sd_obs   = c(0.05, rep(0.4, time - 1))
)

# Data simulation
set.seed(42)
Nobs  <- numeric(time)
theta <- numeric(time - 1)
Nobs[1] <- rlnorm(1, meanlog = 10, sdlog = 0.5)
for(t in 1:(time - 1)){
  theta[t]  <- runif(1, 0.7, 0.9)
  Nobs[t+1] <- Nobs[t] * theta[t]
}
Data_nimble <- list(Nobs = Nobs)

# Initial values
Inits_nimble <- list(
  N           = 2e4 * c(1, cumprod(rep(0.8, time - 1))),
  logit_theta = rep(logit(0.8), time - 1)
)

# Load Monitors -----------------------------------------------------------
monitors = c("N", "theta", "logit_theta")

```

#Step 2. Model M3

```{r Model nimble}
M3.nimble <- nimbleCode({
  # priors
  for(t in 1:(n-1)){
    logit_theta[t] ~ dnorm(mean = 2, sd = 1)
    theta[t] <- ilogit(logit_theta[t])
  }
  N[1] ~ dlnorm(meanlog = 10, sdlog = 5)

  # process model
  for(t in 1:(n-1)){
    N[t+1] <- N[t] * theta[t]
  }

  # observation model
  Nobs[1] ~ dlnorm(meanlog = log(N[1]), sdlog = sd_obs[1])
  for(t in 3:n){
    Nobs[t] ~ dlnorm(meanlog = log(N[t]), sdlog = sd_obs[t])
  }
})

#print(M3.nimble)
```

# Step 3. Building and Compiling the Model

```{r Building & Compiling}
nimbleOptions(buildInterfacesForCompiledNestedNimbleFunctions = TRUE)
nimbleOptions(MCMCsaveHistory = FALSE)

m  <- nimbleModel(code = M3.nimble, name = "M3",
                  constants = Const_nimble,
                  data = Data_nimble,
                  inits = Inits_nimble,buildDerivs=TRUE)
cm <- compileNimble(m)
## build_M is a central object in the samOptiPro package, as it will feed most of the subsequent functions.
build_M <- function() list(
  model    = m,
  cmodel   = cm,
  monitors = monitors,
  code_text = paste(deparse(M3.nimble), collapse = "\n")
)

```

# Step 4 . Diagnosing Differentiability and HMC Eligibility

```{r Diagnosing Differentiability and HMC Eligibility,message=FALSE, warning=FALSE}

cat("\n[MODEL STRUCTURE CHECK]\n")
diag_s <- diagnose_model_structure(model =m,
                                     include_data        = FALSE,
                                     removed_nodes       = NULL,
                                     ignore_patterns     = c("^lifted_", "^logProb_"),
                                     make_plots          = TRUE,
                                     output_dir          ="outputs/diagnostics",
                                     save_csv            = TRUE,
                                     node_of_interest    = NULL,
                                     sampler_times       = NULL,
                                     sampler_times_unit  = "seconds",
                                     auto_profile        = TRUE,
                                     profile_niter       = 5000,
                                     profile_burnin      = 4000,
                                     profile_thin        = 1,
                                     profile_seed        = NULL,
                                     np                  = 0.10,
                                     by_family           = FALSE,
                                     family_stat         = c("median","mean","sum"),
                                     time_normalize      = c("none","per_node"),
                                     only_family_plots   = TRUE)
diag_s$plots 
cat(sprintf("- Stochastic nodes   : %d\n", length(diag_s$stochastic_nodes)))
cat(sprintf("- Deterministic nodes: %d\n", length(diag_s$deterministic_nodes)))
out <- run_structure_and_hmc_test(build_M, include_data = FALSE)

```

# Step 5. Baseline MCMC, Bottelenecks and Performance Assessment
```{r  Baseline MCMC and Performance Assessment,message=FALSE, warning=FALSE}
n.iter   <- 1e6
n.burnin <- 1e4
n.thin   <- 2
n.chains <- 3

res_b <- run_baseline_config(
  build_M,
  niter   = n.iter,
  nburnin = n.burnin,
  nchains = n.chains,
  thin    = n.thin,
  monitors = monitors
)

samples_ml <- as_mcmc_list_sop(res_b$samples, res_b$samples2,
                               drop_loglik = FALSE, thin = n.thin)

runtime_s <- res_b$runtime_s   # Time total
ap  <- assess_performance(samples_ml, runtime_s)

bot<-identify_bottlenecks(samples_ml, runtime_s,
                                 ess_threshold = 1000,
                                 sampler_params = NULL,
                                 model = m,
                                 mcmc_conf = NULL,
                                 ignore_patterns = c("^lifted_","^logProb_"),
                                 strict_sampler_only = TRUE,
                                 auto_configure = TRUE,
                                 rhat_threshold = 1.01,
                                 ess_per_s_min = 0)
runtime_s
ap$summary
bot$top3
bot2<-identify_bottlenecks_family(samples_ml, runtime_s,
                                 ess_threshold = 1000,
                                 sampler_params = NULL,
                                 model = m,
                                 mcmc_conf = NULL,
                                 ignore_patterns = c("^lifted_","^logProb_"),
                                 strict_sampler_only = TRUE,
                                 auto_configure = TRUE,
                                 rhat_threshold = 1.01,
                                 ess_per_s_min = 0)
bot2$top3
```

# Step 6-Adaptive Block Strategy — test_strategy_block()

```{r Adaptive Block Strategy — test_strategy_block(),message=FALSE, warning=FALSE}

diff<-test_strategy_family(build_fn = build_M,
                         monitors            = NULL,   # optional, just passed through
                         try_hmc             = TRUE,   # only used for full-model path; surgical ignores
                         nchains             = 3,
                         pilot_niter         = 4000,
                         pilot_burnin        = 1000,
                         thin                = 2,
                         out_dir             = "outputs/diagnostics",
                         nbot                = 1,
                         # strict sequences (user can override; order strictly enforced)
                         strict_scalar_seq   = c("NUTS","slice","RW"),
                         strict_block_seq    = c("NUTS_block","AF_slice","RW_block"),
                         # forcing
                         force_families      = NULL,   # e.g. c("logit_theta","N")
                         force_nodes         = NULL,   # e.g. list(logit_theta=c("logit_theta[1]",...))
                         force_union         = NULL,   # e.g. c("logit_theta","N")
                         # interaction
                         ask                 = TRUE,
                         ask_before_hmc      = TRUE,
                         # safety caps
                         block_max           = 20,
                         # sampler controls
                         slice_control       = list(),
                         rw_control          = list(),
                         rwblock_control     = list(adaptScaleOnly = TRUE),
                         af_slice_control    = list(),
                         slice_max_contractions = 5000) 
##Forcing
diff2<-test_strategy_family (build_fn = build_M,
                         monitors            = NULL,   # optional, just passed through
                         try_hmc             = FALSE,   # only used for full-model path; surgical ignores
                         nchains             = 3,
                         pilot_niter         = 4000,
                         pilot_burnin        = 1000,
                         thin                = 2,
                         out_dir             = "outputs/diagnostics",
                         nbot                = 2,
                         # strict sequences (user can override; order strictly enforced)
                         strict_scalar_seq   = c("NUTS"),
                         strict_block_seq    = c("NUTS_block"),
                         # forcing
                         force_families      = c("logit_theta","N"),
                         force_nodes         = NULL,   # e.g. list(logit_theta=c("logit_theta[1]",...))
                         force_union         = NULL,   # e.g. c("logit_theta","N")
                         # interaction
                         ask                 = TRUE,
                         ask_before_hmc      = TRUE,
                         # safety caps
                         block_max           = 20,
                         # sampler controls
                         slice_control       = list(),
                         rw_control          = list(),
                         rwblock_control     = list(adaptScaleOnly = TRUE),
                         af_slice_control    = list(),
                         slice_max_contractions = 5000) 
###Pour les singletons
diffB<-test_strategy(build_fn = build_M,
                     monitors            = NULL,   # optional, just passed through
                     try_hmc             = FALSE,   # only used for full-model path; surgical ignores
                     nchains             = 3,
                     pilot_niter         = 4000,
                     pilot_burnin        = 1000,
                     thin                = 2,
                     out_dir             = "outputs/diagnostics",
                     nbot                = 1,
                     # strict sequences (user can override; order strictly enforced)
                     strict_scalar_seq   = c("NUTS","slice","RW"),
                     strict_block_seq    = c("NUTS_block","AF_slice","RW_block"),
                     force_union         = NULL,   # e.g. c("logit_theta","N")
                     # interaction
                     ask                 = TRUE,
                     ask_before_hmc      = TRUE,
                     # safety caps
                     block_max           = 20,
                     # sampler controls
                     slice_control       = list(),
                     rw_control          = list(),
                     rwblock_control     = list(adaptScaleOnly = TRUE),
                     af_slice_control    = list(),slice_max_contractions = 5000)
```

# Step-7. Visualization and Diagnostics
```{r  Visualization and Diagnostics,message=FALSE, warning=FALSE,fig.cap="", out.width="90%",echo=TRUE, results='asis'}
diag_tbl <- compute_diag_from_mcmc(samples_ml, runtime_s = res_b$runtime_s)
conf.mcmc <- nimble::configureMCMC(m)

plots_bn <- plot_bottlenecks(
  diag_tbl,
  sampled_only = FALSE,            # set TRUE for sampled-only nodes
  conf.mcmc = conf.mcmc,
  samples_ml = samples_ml
)

plots_cv <- plot_convergence_checks(
  samples_ml,
  out_dir = "outputs/diagnostics",
  top_k_rhat = 8,
  top_k_aelow = 8,
  runtime_s = 120,                 # total runtime (adjust if needed)
  rhat_ref = 1.01,
  make_rhat_hist = TRUE,
  make_traces_rhat = TRUE,
  make_traces_ae = TRUE,
  make_rhat_family_bars = TRUE
)

plots_bi <- plot_bottlenecks_index(
  diag_tbl,
  out_dir = "outputs/diagnostics",
  top_k = 20L,
  make_hist_ce = TRUE,
  make_hist_ae = TRUE
)

cat("\nCreated bottleneck figures (plot_bottlenecks):\n")
print(names(plots_bn))
cat("\nConvergence outputs (plot_convergence_checks):\n")
print(names(plots_cv))
cat("\nIndex panels (plot_bottlenecks_index):\n")
print(names(plots_bi))
```

#9. Conclusions

This workflow highlights how samOptiPro helps:

Detect non-differentiable nodes that prevent HMC/NUTS usage.

Automatically switch between gradient-based and non-gradient samplers.

Quantify algorithmic and computational efficiency for each parameter family.

Provide transparent diagnostic plots and benchmark reports.

Even for a simple state–space model, the adaptive block design ensures faster convergence and improved mixing without manual tuning.

#10. References
