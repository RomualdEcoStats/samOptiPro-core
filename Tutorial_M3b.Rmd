
---
title: "Optimizing Samplers in NIMBLE"
author:  "Romuald H."
date: "08/09/2020"
documentclass: article
output: 
  bookdown::word_document2:
    fig_caption: yes
    number_sections: no
    reference_docx: "../../Rmarkdown/ICES_template.docx"
bibliography: samOpti.bib
csl: "../../Rmarkdown/ices-journal-of-marine-science.csl"
---

```{r setup, include=FALSE}
rm(list=ls())
library(knitr)
knitr::opts_chunk$set(echo = FALSE,warning=FALSE,message=FALSE,fig.width=14.9/2.54,
                      fig.height=10/2.54,dpi=300)
colorpalette=cbf_1 <- c("#999999", "#E69F00", "#56B4E9", "#009E73", 
                        "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

```

#Introduction

This tutorial demonstrates how to **diagnose differentiability** and **optimize MCMC sampling strategies** in complex Bayesian state–space models using the R package **`samOptiPro`** (Hounyeme *et al.*, 2025).  
We illustrate the workflow on a simple population dynamics model, using `nimble` and `nimbleHMC` as the computational back-end.

We will:
- Build and simulate a **population growth model** with latent process and log-normal observations.
- Identify bottelenecks (Algorithmic bottelenecks or and Time bottelelnecks)
- Diagnose **non-differentiable components** (to decide whether HMC/NUTS is applicable).
- Automatically **benchmark samplers** (RW, Slice, AF_slice, HMC, NUTS) using `test_strategy_block()`.
- Assess **algorithmic (AE)** and **computational efficiency (CE)**.

All results (traceplots, diagnostics, and performance summaries) are saved under `outputs/`.

# Step 0- Load packages
```{r Load Packages}
library(coda)
library(ggplot2)
library(nimble)
library(nimbleHMC)

```

```{r Load samOptiPro package}
devtools::load_all("~/samOptiPro_packages_dev/samOptiPro")
devtools::document()
devtools::load_all()
```
#Step 1. Simulated Data, Initial Values and monitors

```{r Inputs Data & Monitors, echo=FALSE}
# Simulation constants
time <- 8
Const_nimble <- list(
  n        = time,
  sd_dummy = 0.05,
  sd_obs   = c(0.05, rep(0.4, time - 1))
)

# Data simulation
set.seed(42)
Nobs  <- numeric(time)
theta <- numeric(time - 1)
Nobs[1] <- rlnorm(1, meanlog = 10, sdlog = 0.5)
for(t in 1:(time - 1)){
  theta[t]  <- runif(1, 0.7, 0.9)
  Nobs[t+1] <- Nobs[t] * theta[t]
}
Data_nimble <- list(Nobs = Nobs)

# Initial values
Inits_nimble <- list(
  N           = 2e4 * c(1, cumprod(rep(0.8, time - 1))),
  logit_theta = rep(logit(0.8), time - 1)
)

# Load Monitors -----------------------------------------------------------
monitors = c("N", "theta", "logit_theta")

```

#Step 2. Model M3

```{r Model nimble}
M3.nimble <- nimbleCode({
  # priors
  for(t in 1:(n-1)){
    logit_theta[t] ~ dnorm(mean = 2, sd = 1)
    theta[t] <- ilogit(logit_theta[t])
  }
  N[1] ~ dlnorm(meanlog = 10, sdlog = 5)

  # process model
  for(t in 1:(n-1)){
    N[t+1] <- N[t] * theta[t]
  }

  # observation model
  Nobs[1] ~ dlnorm(meanlog = log(N[1]), sdlog = sd_obs[1])
  for(t in 3:n){
    Nobs[t] ~ dlnorm(meanlog = log(N[t]), sdlog = sd_obs[t])
  }
})

#print(M3.nimble)
```

# Step 3. Building and Compiling the Model

```{r Building & Compiling}
nimbleOptions(buildInterfacesForCompiledNestedNimbleFunctions = TRUE)
nimbleOptions(MCMCsaveHistory = FALSE)

m  <- nimbleModel(code = M3.nimble, name = "M3",
                  constants = Const_nimble,
                  data = Data_nimble,
                  inits = Inits_nimble,buildDerivs=TRUE)
cm <- compileNimble(m)
## build_M is a central object in the samOptiPro package, as it will feed most of the subsequent functions.
build_M <- function() list(
  model    = m,
  cmodel   = cm,
  monitors = monitors,
  code_text = paste(deparse(M3.nimble), collapse = "\n")
)

```

# Step 4 . Diagnosing Differentiability and HMC Eligibility

```{r Diagnosing Differentiability and HMC Eligibility,message=FALSE, warning=FALSE}

cat("\n[MODEL STRUCTURE CHECK]\n")
diag_s <- diagnose_model_structure(model =m,
                                     include_data        = FALSE,
                                     removed_nodes       = NULL,
                                     ignore_patterns     = c("^lifted_", "^logProb_"),
                                     make_plots          = TRUE,
                                     output_dir          ="outputs/diagnostics",
                                     save_csv            = FALSE,
                                     node_of_interest    = NULL,
                                     sampler_times       = NULL,
                                     sampler_times_unit  = "seconds",
                                     auto_profile        = FALSE,
                                     profile_niter       = 2200,
                                     profile_burnin      = 500,
                                     profile_thin        = 1,
                                     profile_seed        = NULL,
                                     np                  = 0.10,
                                     by_family           = TRUE,
                                     family_stat         = c("median","mean","sum"),
                                     time_normalize      = c("none","per_node"),
                                     only_family_plots   = TRUE)
#diag_s$plots 
#cat(sprintf("- Stochastic nodes   : %d\n", length(diag_s$stochastic_nodes)))
#cat(sprintf("- Deterministic nodes: %d\n", length(diag_s$deterministic_nodes)))
out <- run_structure_and_hmc_test(build_M, include_data = FALSE)

```

# Step 5. Baseline MCMC, Bottelenecks and Performance Assessment
```{r  Baseline MCMC and Performance Assessment,message=FALSE, warning=FALSE}
n.iter   <- 1e6
n.burnin <- 1e4
n.thin   <- 2
n.chains <- 3

res_a <- run_baseline_config(
  build_M,
  niter   = n.iter,
  nburnin = n.burnin,
  nchains = n.chains,
  thin    = n.thin,
  monitors = monitors
)

samples_mla <- as_mcmc_list_sop(res_a$samples, res_a$samples2,
                               drop_loglik = FALSE, thin = n.thin)

runtime_s_a <- res_a$runtime_s   # Time total
ap  <- assess_performance(samples_mla, runtime_s_a)

bot<-identify_bottlenecks(samples_mla, runtime_s_a,
                                 ess_threshold = 1000,
                                 sampler_params = NULL,
                                 model = m,
                                 mcmc_conf = NULL,
                                 ignore_patterns = c("^lifted_","^logProb_"),
                                 strict_sampler_only = TRUE,
                                 auto_configure = TRUE,
                                 rhat_threshold = 1.01,
                                 ess_per_s_min = 0)
runtime_s_a
ap$summary
bot$top3
bot2<-identify_bottlenecks_family(samples_mla, runtime_s_a,
                                 ess_threshold = 1000,
                                 sampler_params = NULL,
                                 model = m,
                                 mcmc_conf = NULL,
                                 ignore_patterns = c("^lifted_","^logProb_"),
                                 strict_sampler_only = TRUE,
                                 auto_configure = TRUE,
                                 rhat_threshold = 1.01,
                                 ess_per_s_min = 0)
bot2$top3
```

# Step 6-Adaptive Block Strategy — test_strategy_block()

```{r Adaptive Block Strategy — test_strategy_block(),message=FALSE, warning=FALSE}

diff<-test_strategy_family(build_fn = build_M,
                         monitors            = NULL,   # optional, just passed through
                         try_hmc             = TRUE,   # only used for full-model path; surgical ignores
                         nchains             = 3,
                         pilot_niter         = 4000,
                         pilot_burnin        = 1000,
                         thin                = 2,
                         out_dir             = "outputs/diagnostics",
                         nbot                = 1,
                         # strict sequences (user can override; order strictly enforced)
                         strict_scalar_seq   = c("NUTS","slice","RW"),
                         strict_block_seq    = c("NUTS_block","AF_slice","RW_block"),
                         # forcing
                         force_families      = NULL,   # e.g. c("logit_theta","N")
                         force_nodes         = NULL,   # e.g. list(logit_theta=c("logit_theta[1]",...))
                         force_union         = NULL,   # e.g. c("logit_theta","N")
                         # interaction
                         ask                 = TRUE,
                         ask_before_hmc      = TRUE,
                         # safety caps
                         block_max           = 20,
                         # sampler controls
                         slice_control       = list(),
                         rw_control          = list(),
                         rwblock_control     = list(adaptScaleOnly = TRUE),
                         af_slice_control    = list(),
                         slice_max_contractions = 5000) 
##Forcing
diff2<-test_strategy_family (build_fn = build_M,
                         monitors            = NULL,   # optional, just passed through
                         try_hmc             = FALSE,   # only used for full-model path; surgical ignores
                         nchains             = 3,
                         pilot_niter         = 4000,
                         pilot_burnin        = 1000,
                         thin                = 2,
                         out_dir             = "outputs/diagnostics",
                         nbot                = 2,
                         # strict sequences (user can override; order strictly enforced)
                         strict_scalar_seq   = c("NUTS"),
                         strict_block_seq    = c("NUTS_block"),
                         # forcing
                         force_families      = c("logit_theta","N"),
                         force_nodes         = NULL,   # e.g. list(logit_theta=c("logit_theta[1]",...))
                         force_union         = NULL,   # e.g. c("logit_theta","N")
                         # interaction
                         ask                 = TRUE,
                         ask_before_hmc      = TRUE,
                         # safety caps
                         block_max           = 20,
                         # sampler controls
                         slice_control       = list(),
                         rw_control          = list(),
                         rwblock_control     = list(adaptScaleOnly = TRUE),
                         af_slice_control    = list(),
                         slice_max_contractions = 5000) 
###Pour les singletons
diffB<-test_strategy(build_fn = build_M,
                     monitors            = NULL,   # optional, just passed through
                     try_hmc             = FALSE,   # only used for full-model path; surgical ignores
                     nchains             = 3,
                     pilot_niter         = 4000,
                     pilot_burnin        = 1000,
                     thin                = 2,
                     out_dir             = "outputs/diagnostics",
                     nbot                = 1,
                     # strict sequences (user can override; order strictly enforced)
                     strict_scalar_seq   = c("NUTS","slice","RW"),
                     strict_block_seq    = c("NUTS_block","AF_slice","RW_block"),
                     force_union         = NULL,   # e.g. c("logit_theta","N")
                     # interaction
                     ask                 = TRUE,
                     ask_before_hmc      = TRUE,
                     # safety caps
                     block_max           = 20,
                     # sampler controls
                     slice_control       = list(),
                     rw_control          = list(),
                     rwblock_control     = list(adaptScaleOnly = TRUE),
                     af_slice_control    = list(),slice_max_contractions = 5000)
```

# Step-7. Visualization and Diagnostics
```{r  Visualization and Diagnostics,message=FALSE, warning=FALSE,fig.cap="", out.width="90%",echo=TRUE, results='asis'}
diag_tbl <- compute_diag_from_mcmc(samples_mla, runtime_s = res_a$runtime_s)
#diag_tbl <- compute_diag_from_mcmc_vect(samples_mla,runtime_s_a =  res_a$runtime_s,compute_rhat = "both",ess_for = "both",target_block_ram_gb = 2)
conf.mcmc <- nimble::configureMCMC(m)

plots_bn <- plot_bottlenecks(
  diag_tbl,
  sampled_only = TRUE,            # set TRUE for sampled-only nodes
  conf.mcmc = conf.mcmc,
  samples_ml = samples_mla
)

plots_cv <- plot_convergence_checks(
  samples_mla,
  out_dir = "outputs/diagnostics",
  top_k_rhat = 8,
  top_k_aelow = 8,
  runtime_s = 120,                 # total runtime (adjust if needed)
  rhat_ref = 1.01,
  make_rhat_hist = TRUE,
  make_traces_rhat = TRUE,
  make_traces_ae = TRUE,
  make_rhat_family_bars = TRUE
)

plots_bi <- plot_bottlenecks_index(
  diag_tbl,
  out_dir = "outputs/diagnostics",
  top_k = 20L,
  make_hist_ce = TRUE,
  make_hist_ae = TRUE
)

cat("\nCreated bottleneck figures (plot_bottlenecks):\n")
print(names(plots_bn))
cat("\nConvergence outputs (plot_convergence_checks):\n")
print(names(plots_cv))
cat("\nIndex panels (plot_bottlenecks_index):\n")
print(names(plots_bi))
```

#9. Conclusions

This workflow highlights how samOptiPro helps:

Detect non-differentiable nodes that prevent HMC/NUTS usage.

Automatically switch between gradient-based and non-gradient samplers.

Quantify algorithmic and computational efficiency for each parameter family.

Provide transparent diagnostic plots and benchmark reports.

Even for a simple state–space model, the adaptive block design ensures faster convergence and improved mixing without manual tuning.

#10. References
