[{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Romuald Hounyeme Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Romuald Hounyeme. Author, maintainer. Etienne Rivot. Author. Rémi Patin. Contributor. Hilaire Drouineau. Contributor.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hounyeme R, Rivot E (2025). samOptiPro: Optimization Diagnostics Tools Bayesian Stock Assessment Models NIMBLE. R package version 0.1.0, https://github.com/RomualdEcoStats/samOptiPro-core.","code":"@Manual{,   title = {samOptiPro: Optimization and Diagnostics Tools for Bayesian Stock Assessment Models in NIMBLE},   author = {Romuald Hounyeme and Etienne Rivot},   year = {2025},   note = {R package version 0.1.0},   url = {https://github.com/RomualdEcoStats/samOptiPro-core}, }"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/index.html","id":"samoptipro-010","dir":"","previous_headings":"","what":"Optimization and Diagnostics Tools for Bayesian Stock Assessment Models in NIMBLE","title":"Optimization and Diagnostics Tools for Bayesian Stock Assessment Models in NIMBLE","text":"samOptiPro — Systematic Optimization Bayesian Stock Assessment Models NIMBLE workflow-driven helper configure, assess, optimise MCMC sampling NIMBLE, following reproducible decision tree: general tools → assess → detect poor performance → identify bottlenecks → (model surgery | custom samplers) → reassess → validate → iterate.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/index.html","id":"id_️-overview","dir":"","previous_headings":"","what":"✳️ Overview","title":"Optimization and Diagnostics Tools for Bayesian Stock Assessment Models in NIMBLE","text":"samOptiPro provide advanced, modular workflow diagnosing, benchmarking, optimizing hierarchical ecological models (SAM-like frameworks) built NIMBLE. integrates: - Structural diagnostics: detect non-differentiable nodes (truncations, Dirichlet, simplex constraints…) - Adaptive sampler configuration: auto-assign Slice / AF_slice / RW / Block / HMC / NUTS - Performance analytics: algorithmic (ESS, ESS/s) computational (runtime) efficiency - Automatic visual reports: bottlenecks, convergence, Rhat distributions - Differentiability testing: seamless handoff gradient-based inference (nimbleHMC) - Hybrid family strategy: use block samplers adaptive HMC correlations demand ","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/index.html","id":"id_️-installation","dir":"","previous_headings":"","what":"⚙️ Installation","title":"Optimization and Diagnostics Tools for Bayesian Stock Assessment Models in NIMBLE","text":"```r # local development directory devtools::load_all(“samOptiPro”)","code":""},{"path":[]},{"path":[]},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/as_mcmc_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an object to mcmc.list — as_mcmc_list","title":"Convert an object to mcmc.list — as_mcmc_list","text":"Converts mcmc.list / mcmc / data.frame / matrix coda-compatible mcmc.list.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/as_mcmc_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an object to mcmc.list — as_mcmc_list","text":"","code":"as_mcmc_list(x)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/as_mcmc_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an object to mcmc.list — as_mcmc_list","text":"x object class mcmc.list, mcmc, data.frame, matrix.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/as_mcmc_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert an object to mcmc.list — as_mcmc_list","text":"object class mcmc.list.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/as_mcmc_list_sop.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert various sample formats to coda::mcmc.list (optionally merging samples2) — as_mcmc_list_sop","title":"Convert various sample formats to coda::mcmc.list (optionally merging samples2) — as_mcmc_list_sop","text":"Convert various sample formats coda::mcmc.list (optionally merging samples2)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/as_mcmc_list_sop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert various sample formats to coda::mcmc.list (optionally merging samples2) — as_mcmc_list_sop","text":"","code":"as_mcmc_list_sop(samples, samples2 = NULL, drop_loglik = FALSE, thin = 1L)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/as_mcmc_list_sop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert various sample formats to coda::mcmc.list (optionally merging samples2) — as_mcmc_list_sop","text":"samples list/matrix/mcmc/list samples2 optional list/matrix/mcmc.list drop_loglik drop log-likelihood columns thin thinning returned mcmc objects","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/as_mcmc_list_sop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert various sample formats to coda::mcmc.list (optionally merging samples2) — as_mcmc_list_sop","text":"coda::mcmc.list","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/assess_performance.html","id":null,"dir":"Reference","previous_headings":"","what":"ESS, Rhat, AE, CE and run-level summary — assess_performance","title":"ESS, Rhat, AE, CE and run-level summary — assess_performance","text":"Computes, per parameter: ESS, \\(\\hat{R}\\), AE = ESS / (iters * chains), CE = ESS / seconds, returns global summary (including total ESS ESS/s).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/assess_performance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ESS, Rhat, AE, CE and run-level summary — assess_performance","text":"","code":"assess_performance(samples, runtime_s, rhat_thresh = 1.01)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/assess_performance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ESS, Rhat, AE, CE and run-level summary — assess_performance","text":"samples mcmc.list / mcmc / data.frame compatible coda. runtime_s Total wall time seconds (numeric). rhat_thresh \\(\\hat{R}\\) threshold used \"OK\" proportion (default 1.01).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/assess_performance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ESS, Rhat, AE, CE and run-level summary — assess_performance","text":"list summary (tibble) per_param (tibble).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/build_conf_with_monitors.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a fresh MCMC configuration with automatic monitors if missing — build_conf_with_monitors","title":"Build a fresh MCMC configuration with automatic monitors if missing — build_conf_with_monitors","text":"Build fresh MCMC configuration automatic monitors missing","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/build_conf_with_monitors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a fresh MCMC configuration with automatic monitors if missing — build_conf_with_monitors","text":"","code":"build_conf_with_monitors(model, monitors = NULL, opts = samOptiPro_options())"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/build_conf_with_monitors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a fresh MCMC configuration with automatic monitors if missing — build_conf_with_monitors","text":"model nimbleModel (ou compile; accepte les deux) monitors optional character vector; NULL, auto-discover opts samOptiPro_options()","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/checkInits.html","id":null,"dir":"Reference","previous_headings":"","what":"Robustly check initial values against a compiled NIMBLE model — checkInits","title":"Robustly check initial values against a compiled NIMBLE model — checkInits","text":"Robustly check initial values compiled NIMBLE model","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/checkInits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Robustly check initial values against a compiled NIMBLE model — checkInits","text":"","code":"checkInits(model, inits, silent = FALSE)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/checkInits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Robustly check initial values against a compiled NIMBLE model — checkInits","text":"model NIMBLE model object (function builds one) inits list initial values silent logical","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/checkInits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Robustly check initial values against a compiled NIMBLE model — checkInits","text":"logical TRUE valid; otherwise throws informative error","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/checkInitsAndRun.html","id":null,"dir":"Reference","previous_headings":"","what":"Check inits then run MCMC — checkInitsAndRun","title":"Check inits then run MCMC — checkInitsAndRun","text":"Check inits run MCMC","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/checkInitsAndRun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check inits then run MCMC — checkInitsAndRun","text":"","code":"checkInitsAndRun(run_fn, inits, ...)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/checkInitsAndRun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check inits then run MCMC — checkInitsAndRun","text":"run_fn function signature function(inits) -> list(samples=samples, runtime_s=seconds) inits list (list lists chains) ... forwarded run_fn","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/checkInitsAndRun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check inits then run MCMC — checkInitsAndRun","text":"list(samples, runtime_s)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/compute_WAIC.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute WAIC from coda samples that include logLik[] columns — compute_WAIC","title":"Compute WAIC from coda samples that include logLik[] columns — compute_WAIC","text":"Compute WAIC coda samples include logLik[] columns","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/compute_WAIC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute WAIC from coda samples that include logLik[] columns — compute_WAIC","text":"","code":"compute_WAIC(samples)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/compute_WAIC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute WAIC from coda samples that include logLik[] columns — compute_WAIC","text":"samples coda::mcmc.list","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/compute_diag_from_mcmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a standard diagnostics table from a coda::mcmc.list — compute_diag_from_mcmc","title":"Build a standard diagnostics table from a coda::mcmc.list — compute_diag_from_mcmc","text":"Columns: target, ESS, AE_ESS_per_it (ESS/iterations), ESS_per_sec, time_s_per_ESS, Rhat, Family.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/compute_diag_from_mcmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a standard diagnostics table from a coda::mcmc.list — compute_diag_from_mcmc","text":"","code":"compute_diag_from_mcmc(samples, runtime_s)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/compute_diag_from_mcmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a standard diagnostics table from a coda::mcmc.list — compute_diag_from_mcmc","text":"samples mcmc.list (single mcmc / matrix accepted). runtime_s Numeric(1); wall-clock runtime seconds.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/compute_diag_from_mcmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a standard diagnostics table from a coda::mcmc.list — compute_diag_from_mcmc","text":"data.frame diag_tbl.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/configure_hmc_safely.html","id":null,"dir":"Reference","previous_headings":"","what":"Configure and run HMC/NUTS safely — configure_hmc_safely","title":"Configure and run HMC/NUTS safely — configure_hmc_safely","text":"Sets HMC/NUTS configuration via nimbleHMC, compiles MCMC, runs , returns basic diagnostics.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/configure_hmc_safely.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Configure and run HMC/NUTS safely — configure_hmc_safely","text":"","code":"configure_hmc_safely(   build_fn,   niter,   nburnin,   thin,   monitors,   nchains,   out_dir = NULL )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/configure_hmc_safely.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Configure and run HMC/NUTS safely — configure_hmc_safely","text":"build_fn function builds model returns least list components model conf. niter, nburnin, thin Integers; MCMC iterations, burn-, thinning. monitors Character vector node names monitor. nchains Integer; number chains run. out_dir Character NULL; NULL, figures saved .","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/configure_hmc_safely.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Configure and run HMC/NUTS safely — configure_hmc_safely","text":"list elements: conf configured MCMC configuration. res Raw run output (samples, runtime, …). diag_tbl data frame diagnostics (e.g., R-hat, ESS/s).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/configure_hmc_safely.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Configure and run HMC/NUTS safely — configure_hmc_safely","text":"","code":"if (FALSE) { # \\dontrun{   out <- configure_hmc_safely(     build_fn = my_build_fn, niter = 2000, nburnin = 1000, thin = 1,     monitors = c(\"beta[1]\", \"sigma\"), nchains = 4, out_dir = \"outputs\"   )   out$diag_tbl } # }"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/diagnose_model_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Diagnose model structure, dependencies, and per-sampler time (parameter- and family-level) — diagnose_model_structure","title":"Diagnose model structure, dependencies, and per-sampler time (parameter- and family-level) — diagnose_model_structure","text":"Inspect NIMBLE model extract universe nodes, classify stochastic vs. deterministic nodes, compute downstream dependencies per node, map configured samplers target nodes, (optionally) profile per-sampler run time. Produces tidy tables publication-quality figures parameter level family level (\"family\" = base variable name \",j\" index, replacing indices []). Key features: Robust filtering nodes (ignored patterns, removal list). Downstream dependency counts per node (+ per family via summary stats). Per-sampler times aggregated parameters (+ per family optional normalization). Optional auto-profiling samplers via short MCMC run. Non-regressive: original per-parameter plots preserved default.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/diagnose_model_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diagnose model structure, dependencies, and per-sampler time (parameter- and family-level) — diagnose_model_structure","text":"","code":"diagnose_model_structure(   model,   include_data = FALSE,   removed_nodes = NULL,   ignore_patterns = c(\"^lifted_\", \"^logProb_\"),   make_plots = TRUE,   output_dir = NULL,   save_csv = FALSE,   node_of_interest = NULL,   sampler_times = NULL,   sampler_times_unit = \"seconds\",   auto_profile = TRUE,   profile_niter = 2000L,   profile_burnin = 500L,   profile_thin = 1L,   profile_seed = NULL,   np = 0.1,   by_family = TRUE,   family_stat = c(\"median\", \"mean\", \"sum\"),   time_normalize = c(\"none\", \"per_node\"),   only_family_plots = FALSE,   ... )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/diagnose_model_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diagnose model structure, dependencies, and per-sampler time (parameter- and family-level) — diagnose_model_structure","text":"model compiled uncompiled nimbleModel (required). include_data Logical; include data nodes enumerating nodes (default FALSE). removed_nodes Character vector nodes exclude explicitly (default NULL). ignore_patterns Character vector regex patterns exclude (e.g., \"^lifted_\", \"^logProb_\"). make_plots Logical; TRUE, generate ggplot objects optionally save (default TRUE). output_dir Directory figures/CSVs saved; NULL, nothing written (default NULL). save_csv Logical; TRUE, write CSV exports (dependencies per node, family tables) (default FALSE). node_of_interest Optional character vector nodes highlight subset (reserved user logic) (default NULL). sampler_times Optional numeric vector per-sampler times aligned nimble::configureMCMC(model)$getSamplers(). sampler_times_unit Character label time axis (e.g., \"seconds\", \"ms\") (default \"seconds\"). auto_profile Logical; TRUE sampler_times NULL, profile sampler times automatically (default TRUE). profile_niter Integer; iterations used auto-profiler (default 2000L). profile_burnin Integer; burn-iterations auto-profiler (default 500L). profile_thin Integer; thinning auto-profiler (default 1L). profile_seed Optional integer seed reproducibility (default NULL). np Proportion (0,1] used elsewhere \"worst sampler\" selection (kept API compatibility) (default 0.10). by_family Logical; TRUE, compute plot family-level summaries addition parameter-level (default TRUE). family_stat One c(\"median\",\"mean\",\"sum\"); summary statistic family-level aggregation (default \"median\"). time_normalize One c(\"none\",\"per_node\"); \"per_node\", divide family time number distinct nodes stats::family(default \"none\"). only_family_plots Logical; TRUE, family-level figures exported (parameter plots written). ... Additional arguments forwarded nimble::configureMCMC().","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/diagnose_model_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diagnose model structure, dependencies, and per-sampler time (parameter- and family-level) — diagnose_model_structure","text":"named list containing: dependencies_df        : data.frame (node, dependency) pairs, dep_counts             : data.frame per-parameter downstream dependency counts, samplers_df            : data.frame listing samplers target nodes (list-column), per_param_times        : data.frame per-parameter aggregated sampler time, deps_df                : tidy data.frame used parameter-level dependency plotting, sampler_df             : tidy data.frame used parameter-level time plotting, fam_deps_df            : family-level dependency summary (statistic per family), fam_time_df            : family-level time summary (optionally normalized), plots                  : list ggplot objects (may NULL created): plot_dependencies, plot_sampler_time, plot_combined, plot_dependencies_family, plot_sampler_time_family, plot_combined_family.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/diagnose_model_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diagnose model structure, dependencies, and per-sampler time (parameter- and family-level) — diagnose_model_structure","text":"","code":"if (FALSE) { # \\dontrun{ res <- diagnose_model_structure(   model = my_nimble_model,   make_plots = TRUE,   output_dir = \"outputs/diagnostics\",   save_csv = TRUE,   by_family = TRUE,   family_stat = \"median\",   time_normalize = \"per_node\",   only_family_plots = FALSE ) } # }"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/diagnostics_by_target.html","id":null,"dir":"Reference","previous_headings":"","what":"Target-level diagnostics (time + optional step-size proxy) — diagnostics_by_target","title":"Target-level diagnostics (time + optional step-size proxy) — diagnostics_by_target","text":"Builds robust MCMC configuration, profiles per-sampler time profile_sampler_times, maps samplers targets, optionally computes step-size proxy per target via proxy_step_sd samples provided.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/diagnostics_by_target.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Target-level diagnostics (time + optional step-size proxy) — diagnostics_by_target","text":"","code":"diagnostics_by_target(   build_fn,   opts = samOptiPro_options(),   niter = opts$time_profile_n,   samples = NULL )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/diagnostics_by_target.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Target-level diagnostics (time + optional step-size proxy) — diagnostics_by_target","text":"build_fn builder function returning list(model=, cmodel=, monitors=?). opts list options (e.g., samOptiPro_options()). niter Integer; iterations time profiling (defaults opts$time_profile_n). samples Optional coda::mcmc.list used compute step proxy.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/diagnostics_by_target.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Target-level diagnostics (time + optional step-size proxy) — diagnostics_by_target","text":"data.frame columns target, type, time_s, step_sd.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/diagnostics_by_target.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Target-level diagnostics (time + optional step-size proxy) — diagnostics_by_target","text":"Note: uses tolerant default monitor set followed robust configuration (monitors= passed directly configureMCMC).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-avail_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Available variable roots present in a model — .avail_vars","title":"Available variable roots present in a model — .avail_vars","text":"Available variable roots present model","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-avail_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Available variable roots present in a model — .avail_vars","text":"","code":".avail_vars(model)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-barrier_before_block.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporarily switch nimble buildDir (clear compiled & GC) — .barrier_before_block","title":"Temporarily switch nimble buildDir (clear compiled & GC) — .barrier_before_block","text":"Temporarily switch nimble buildDir (clear compiled & GC)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-barrier_before_block.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporarily switch nimble buildDir (clear compiled & GC) — .barrier_before_block","text":"","code":".barrier_before_block(tag = \"scalar_to_block\")"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-barrier_before_block.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporarily switch nimble buildDir (clear compiled & GC) — .barrier_before_block","text":"tag Character tag used temp dir name.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-barrier_before_block.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporarily switch nimble buildDir (clear compiled & GC) — .barrier_before_block","text":"TRUE (invisibly).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-compile_mcmc_with_build.html","id":null,"dir":"Reference","previous_headings":"","what":"Compile a nimble MCMC for a given build object — .compile_mcmc_with_build","title":"Compile a nimble MCMC for a given build object — .compile_mcmc_with_build","text":"Always compiles MCMC R-level model used build step (build_obj$model). avoids subtle mismatches.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-compile_mcmc_with_build.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compile a nimble MCMC for a given build object — .compile_mcmc_with_build","text":"","code":".compile_mcmc_with_build(conf, build_obj, reset = TRUE, show = FALSE)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-compile_mcmc_with_build.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compile a nimble MCMC for a given build object — .compile_mcmc_with_build","text":"conf configureMCMC object. build_obj list returned build function (must contain $model). reset Logical; passed nimble::compileNimble. show Logical; show compiler output.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-compile_mcmc_with_build.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compile a nimble MCMC for a given build object — .compile_mcmc_with_build","text":"compiled MCMC object returned nimble::compileNimble().","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-configure_with_monitors.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a configureMCMC with sanitized/expanded monitors — .configure_with_monitors","title":"Build a configureMCMC with sanitized/expanded monitors — .configure_with_monitors","text":"Build configureMCMC sanitized/expanded monitors","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-configure_with_monitors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a configureMCMC with sanitized/expanded monitors — .configure_with_monitors","text":"","code":".configure_with_monitors(   model,   monitors = NULL,   thin = 1L,   thin2 = NULL,   opts = samOptiPro_options() )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-configure_with_monitors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a configureMCMC with sanitized/expanded monitors — .configure_with_monitors","text":"model Nimble model (R-level compiled). monitors Monitors roots (optional). thin, thin2 Thinning monitors / monitors2. opts Optional package options (defaults elsewhere).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-configure_with_monitors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a configureMCMC with sanitized/expanded monitors — .configure_with_monitors","text":"configureMCMC object thin/thin2 harmonised attributes: ._sop_monitors_roots, ._sop_monitors2_roots, ._sop_monitors_nodes, ._sop_monitors2_nodes.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-default_sanitize_roots.html","id":null,"dir":"Reference","previous_headings":"","what":"Discover default monitors from a nimble model (variable-level) — .default_sanitize_roots","title":"Discover default monitors from a nimble model (variable-level) — .default_sanitize_roots","text":"Retourne des NOMS DE VARIABLES (sans indices) pour laisser le runner poser ensuite les monitors correctement via conf$setMonitors / setMonitors2.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-default_sanitize_roots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discover default monitors from a nimble model (variable-level) — .default_sanitize_roots","text":"","code":".default_sanitize_roots(x)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-default_sanitize_roots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discover default monitors from a nimble model (variable-level) — .default_sanitize_roots","text":"model nimbleModel opts list samOptiPro_options(); champs supportes : include_data      : logical, inclure les data nodes dans l'exploration (rarement utile) include_logLik    : logical, inclure \"logLik\" dans la selection par defaut extra_monitors    : character(), variables supplementaires monitorer (samples) extra_monitors2   : character(), variables supplementaires monitorer en monitors2 (samples2)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-default_sanitize_roots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discover default monitors from a nimble model (variable-level) — .default_sanitize_roots","text":"character() de noms de variables sans indices (ex: \"sd_proc\",\"z\",\"p\",\"logLik\")","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-plot_rhat_bar.html","id":null,"dir":"Reference","previous_headings":"","what":"Save a bar chart of R-hat for selected nodes — .plot_rhat_bar","title":"Save a bar chart of R-hat for selected nodes — .plot_rhat_bar","text":"Save bar chart R-hat selected nodes","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-plot_rhat_bar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save a bar chart of R-hat for selected nodes — .plot_rhat_bar","text":"","code":".plot_rhat_bar(diag_tbl, nodes, out_file)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-plot_traces.html","id":null,"dir":"Reference","previous_headings":"","what":"Save trace plots for a set of nodes — .plot_traces","title":"Save trace plots for a set of nodes — .plot_traces","text":"Save trace plots set nodes","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-plot_traces.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save trace plots for a set of nodes — .plot_traces","text":"","code":".plot_traces(mcmc_list, nodes, out_file_prefix)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-print_monitors.html","id":null,"dir":"Reference","previous_headings":"","what":"Pretty-print selected monitors (optional) — .print_monitors","title":"Pretty-print selected monitors (optional) — .print_monitors","text":"Pretty-print selected monitors (optional)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-print_monitors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pretty-print selected monitors (optional) — .print_monitors","text":"","code":".print_monitors(title, nodes, thin = 1L)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-restore_builddir.html","id":null,"dir":"Reference","previous_headings":"","what":"Restore previous nimble buildDir if it was changed — .restore_builddir","title":"Restore previous nimble buildDir if it was changed — .restore_builddir","text":"Restore previous nimble buildDir changed","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-restore_builddir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restore previous nimble buildDir if it was changed — .restore_builddir","text":"","code":".restore_builddir()"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_cbind_align.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind two matrices by rows count (truncate to common minimum) — .sop_cbind_align","title":"Bind two matrices by rows count (truncate to common minimum) — .sop_cbind_align","text":"Bind two matrices rows count (truncate common minimum)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_cbind_align.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind two matrices by rows count (truncate to common minimum) — .sop_cbind_align","text":"","code":".sop_cbind_align(m1, m2)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_detect_chain_prefix.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect chain prefix ","title":"Detect chain prefix ","text":"Detect chain prefix \"chainK.\" column names","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_detect_chain_prefix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect chain prefix ","text":"","code":".sop_detect_chain_prefix(nms)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_expand_roots_to_nodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand many roots to nodes — .sop_expand_roots_to_nodes","title":"Expand many roots to nodes — .sop_expand_roots_to_nodes","text":"Expand many roots nodes","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_expand_roots_to_nodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand many roots to nodes — .sop_expand_roots_to_nodes","text":"","code":".sop_expand_roots_to_nodes(mdl, roots)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_expand_var_nodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand one root to nodes via getVarInfo() — .sop_expand_var_nodes","title":"Expand one root to nodes via getVarInfo() — .sop_expand_var_nodes","text":"Expand one root nodes via getVarInfo()","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_expand_var_nodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand one root to nodes via getVarInfo() — .sop_expand_var_nodes","text":"","code":".sop_expand_var_nodes(mdl, v)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_get_uncompiled_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the R-level (uncompiled) nimble model when given either R or compiled model — .sop_get_uncompiled_model","title":"Return the R-level (uncompiled) nimble model when given either R or compiled model — .sop_get_uncompiled_model","text":"Return R-level (uncompiled) nimble model given either R compiled model","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_get_uncompiled_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the R-level (uncompiled) nimble model when given either R or compiled model — .sop_get_uncompiled_model","text":"","code":".sop_get_uncompiled_model(x)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_get_uncompiled_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the R-level (uncompiled) nimble model when given either R or compiled model — .sop_get_uncompiled_model","text":"x nimble model compiled model-like object.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_get_uncompiled_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the R-level (uncompiled) nimble model when given either R or compiled model — .sop_get_uncompiled_model","text":"R-level model environment found, otherwise x unchanged.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_has_model_api.html","id":null,"dir":"Reference","previous_headings":"","what":"Heuristic check that an object exposes nimble model API — .sop_has_model_api","title":"Heuristic check that an object exposes nimble model API — .sop_has_model_api","text":"Heuristic check object exposes nimble model API","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_has_model_api.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Heuristic check that an object exposes nimble model API — .sop_has_model_api","text":"","code":".sop_has_model_api(x)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_has_model_api.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Heuristic check that an object exposes nimble model API — .sop_has_model_api","text":"x object.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_has_model_api.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Heuristic check that an object exposes nimble model API — .sop_has_model_api","text":"Logical.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_is_chol_ok.html","id":null,"dir":"Reference","previous_headings":"","what":"Cholesky check — .sop_is_chol_ok","title":"Cholesky check — .sop_is_chol_ok","text":"Cholesky check","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_is_chol_ok.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cholesky check — .sop_is_chol_ok","text":"","code":".sop_is_chol_ok(S)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_is_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Is this a nimble model? — .sop_is_model","title":"Is this a nimble model? — .sop_is_model","text":"nimble model?","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_is_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is this a nimble model? — .sop_is_model","text":"","code":".sop_is_model(x)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_is_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is this a nimble model? — .sop_is_model","text":"x object.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_is_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is this a nimble model? — .sop_is_model","text":"Logical.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_make_propCov_PD.html","id":null,"dir":"Reference","previous_headings":"","what":"Try to make a symmetric matrix positive definite (nearPD/shrinkage/jitter) — .sop_make_propCov_PD","title":"Try to make a symmetric matrix positive definite (nearPD/shrinkage/jitter) — .sop_make_propCov_PD","text":"Try make symmetric matrix positive definite (nearPD/shrinkage/jitter)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_make_propCov_PD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Try to make a symmetric matrix positive definite (nearPD/shrinkage/jitter) — .sop_make_propCov_PD","text":"","code":".sop_make_propCov_PD(   S,   jitter_seq = c(0, 1e-10, 1e-08, 1e-06, 1e-04, 0.01),   shrink_grid = c(0, 0.05, 0.1, 0.2, 0.4) )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_make_propCov_PD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Try to make a symmetric matrix positive definite (nearPD/shrinkage/jitter) — .sop_make_propCov_PD","text":"S Symmetric matrix. jitter_seq Numeric vector diagonal jitter values. shrink_grid Numeric vector shrinkage weights toward diag.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_make_propCov_PD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Try to make a symmetric matrix positive definite (nearPD/shrinkage/jitter) — .sop_make_propCov_PD","text":"PD matrix NULL.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_sanitize_roots.html","id":null,"dir":"Reference","previous_headings":"","what":"Sanitize monitor roots (drop numerics & empties) — .sop_sanitize_roots","title":"Sanitize monitor roots (drop numerics & empties) — .sop_sanitize_roots","text":"Sanitize monitor roots (drop numerics & empties)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_sanitize_roots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sanitize monitor roots (drop numerics & empties) — .sop_sanitize_roots","text":"","code":".sop_sanitize_roots(x)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_sanitize_roots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sanitize monitor roots (drop numerics & empties) — .sop_sanitize_roots","text":"x Character vector.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_sanitize_roots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sanitize monitor roots (drop numerics & empties) — .sop_sanitize_roots","text":"Character vector.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_split_into_blocks.html","id":null,"dir":"Reference","previous_headings":"","what":"Correlation-based clustering into compact blocks — .sop_split_into_blocks","title":"Correlation-based clustering into compact blocks — .sop_split_into_blocks","text":"Correlation-based clustering compact blocks","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_split_into_blocks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Correlation-based clustering into compact blocks — .sop_split_into_blocks","text":"","code":".sop_split_into_blocks(M, max_block = 40L, min_corr = 0.2)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_split_into_blocks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Correlation-based clustering into compact blocks — .sop_split_into_blocks","text":"M Numeric matrix columns = variables. max_block Max block size. min_corr (Reserved) minimal correlation target (enforced yet).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_split_into_blocks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Correlation-based clustering into compact blocks — .sop_split_into_blocks","text":"List character vectors (column names per block).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_strip_chain_prefix.html","id":null,"dir":"Reference","previous_headings":"","what":"Strip ","title":"Strip ","text":"Strip \"chainK.\" prefix column names","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_strip_chain_prefix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Strip ","text":"","code":".sop_strip_chain_prefix(nms)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_supports_derivs.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if derivatives/HMC are supported for a nimble model — .sop_supports_derivs","title":"Check if derivatives/HMC are supported for a nimble model — .sop_supports_derivs","text":"Check derivatives/HMC supported nimble model","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_supports_derivs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if derivatives/HMC are supported for a nimble model — .sop_supports_derivs","text":"","code":".sop_supports_derivs(model)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_supports_derivs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if derivatives/HMC are supported for a nimble model — .sop_supports_derivs","text":"model Nimble model.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-sop_supports_derivs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if derivatives/HMC are supported for a nimble model — .sop_supports_derivs","text":"Logical.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_expand_compact_node.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand a compact node Character scalar, e.g. p[1, 1:3] into explicit indices (numeric only) — .us_expand_compact_node","title":"Expand a compact node Character scalar, e.g. p[1, 1:3] into explicit indices (numeric only) — .us_expand_compact_node","text":"Expand compact node Character scalar, e.g. p[1, 1:3] explicit indices (numeric )","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_expand_compact_node.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand a compact node Character scalar, e.g. p[1, 1:3] into explicit indices (numeric only) — .us_expand_compact_node","text":"","code":".us_expand_compact_node(node)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_expand_compact_node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand a compact node Character scalar, e.g. p[1, 1:3] into explicit indices (numeric only) — .us_expand_compact_node","text":"node Single node string.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_expand_compact_node.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand a compact node Character scalar, e.g. p[1, 1:3] into explicit indices (numeric only) — .us_expand_compact_node","text":"Character vector expanded nodes node expandable.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_expand_vars_to_nodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand variable roots (e.g. ","title":"Expand variable roots (e.g. ","text":"Expand variable roots (e.g. \"beta\") explicit node names using model metadata","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_expand_vars_to_nodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand variable roots (e.g. ","text":"","code":".us_expand_vars_to_nodes(model, vars)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_expand_vars_to_nodes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand variable roots (e.g. ","text":"model Nimble model (R-level compiled). vars Character vector variable roots.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_expand_vars_to_nodes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand variable roots (e.g. ","text":"Character vector node names present model.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_sanitize_monitors.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop numeric junk & control tokens from monitors — .us_sanitize_monitors","title":"Drop numeric junk & control tokens from monitors — .us_sanitize_monitors","text":"Drop numeric junk & control tokens monitors","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_sanitize_monitors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop numeric junk & control tokens from monitors — .us_sanitize_monitors","text":"","code":".us_sanitize_monitors(x)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_sanitize_monitors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Drop numeric junk & control tokens from monitors — .us_sanitize_monitors","text":"x Character vector.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_sanitize_monitors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Drop numeric junk & control tokens from monitors — .us_sanitize_monitors","text":"Clean character vector.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_tokenize_monitors.html","id":null,"dir":"Reference","previous_headings":"","what":"Tokenize a monitors specification into clean symbols — .us_tokenize_monitors","title":"Tokenize a monitors specification into clean symbols — .us_tokenize_monitors","text":"Tokenize monitors specification clean symbols","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_tokenize_monitors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tokenize a monitors specification into clean symbols — .us_tokenize_monitors","text":"","code":".us_tokenize_monitors(x)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_tokenize_monitors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tokenize a monitors specification into clean symbols — .us_tokenize_monitors","text":"x Character vector scalar.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/dot-us_tokenize_monitors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tokenize a monitors specification into clean symbols — .us_tokenize_monitors","text":"Character vector tokens, empties.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/ensure_monitors_exist.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure monitors exist on the model (variable-aware) — ensure_monitors_exist","title":"Ensure monitors exist on the model (variable-aware) — ensure_monitors_exist","text":"Valide une liste de monitors donnee au NIVEAU VARIABLE (sans indices). Ne \"coupe\" plus selon les noeuds indexes ; verifie juste que la VARIABLE existe.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/ensure_monitors_exist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure monitors exist on the model (variable-aware) — ensure_monitors_exist","text":"","code":"ensure_monitors_exist(model, monitors)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/ensure_monitors_exist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure monitors exist on the model (variable-aware) — ensure_monitors_exist","text":"model nimbleModel monitors character() de noms de variables (ex: \"z\",\"p\",\"sd_proc\",\"logLik\")","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/ensure_monitors_exist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensure monitors exist on the model (variable-aware) — ensure_monitors_exist","text":"sous-ensemble valide de monitors, avec warning soft si certains manquent","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/grapes-or-or-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify per-parameter bottlenecks (low ESS/s, low ESS/post-draw, long time-to-target) — %||%","title":"Identify per-parameter bottlenecks (low ESS/s, low ESS/post-draw, long time-to-target) — %||%","text":"Ranks parameters : CE (ESS/s): low worse, AE (ESS/post-draw): low worse, slow_node_time (seconds reach ess_threshold current CE): high worse.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/grapes-or-or-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify per-parameter bottlenecks (low ESS/s, low ESS/post-draw, long time-to-target) — %||%","text":"","code":"x %||% y"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/grapes-or-or-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify per-parameter bottlenecks (low ESS/s, low ESS/post-draw, long time-to-target) — %||%","text":"samples mcmc.list/mcmc/matrix/data.frame. runtime_s numeric(1) wall time seconds. ess_threshold numeric(1) target ESS per parameter (default 1000). sampler_params character() optional vector parameter names keep (stochastic nodes samplers). rhat_threshold numeric(1) kept API symmetry (used ranking). ess_per_s_min numeric(1) optional CE threshold; flags params (0 = inactive).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/grapes-or-or-grapes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify per-parameter bottlenecks (low ESS/s, low ESS/post-draw, long time-to-target) — %||%","text":"list(type=\"ok\" \"degenerate_only\", details=list(ce=..., ae=..., time=..., degenerate=...), per_param=..., summary=..., top3=data.frame)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/grapes-or-or-grapes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Identify per-parameter bottlenecks (low ESS/s, low ESS/post-draw, long time-to-target) — %||%","text":"Degenerate parameters (non-finite non-positive ESS, AE, CE) listed degenerate excluded rankings. pass sampler_params, results restricted parameters (useful exclude deterministic monitors keep stochastic nodes samplers ).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/identify_bottlenecks_family.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify bottlenecks by parameter stats::family(medians within families) — identify_bottlenecks_family","title":"Identify bottlenecks by parameter stats::family(medians within families) — identify_bottlenecks_family","text":"Parameters grouped stats::family(prefix first [), family-level medians computed: AE_med  = median(AE)            (low = worse), CE_med  = median(CE)            (low = worse, CE = ESS/s), ESS_med = median(ESS), Rhat_med= median(Rhat, na.rm=TRUE).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/identify_bottlenecks_family.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify bottlenecks by parameter stats::family(medians within families) — identify_bottlenecks_family","text":"","code":"identify_bottlenecks_family(   samples,   runtime_s,   ess_threshold = 1000,   sampler_params = NULL,   model = NULL,   mcmc_conf = NULL,   ignore_patterns = c(\"^lifted_\", \"^logProb_\"),   strict_sampler_only = TRUE,   auto_configure = TRUE,   rhat_threshold = 1.01,   ess_per_s_min = 0 )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/identify_bottlenecks_family.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify bottlenecks by parameter stats::family(medians within families) — identify_bottlenecks_family","text":"samples mcmc.list/mcmc/matrix/data.frame. runtime_s numeric(1) wall time seconds. ess_threshold numeric(1) target ESS per stats::family(default 1000). sampler_params character() optional vector parameter names keep. rhat_threshold numeric(1) kept API symmetry (used ranks). ess_per_s_min numeric(1) optional CE threshold flag (0 = inactive).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/identify_bottlenecks_family.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify bottlenecks by parameter stats::family(medians within families) — identify_bottlenecks_family","text":"list(type=\"ok\" \"degenerate_only\", details=list(ce=..., ae=..., time=..., degenerate=...), per_family=..., summary=..., top3=data.frame) identify_bottlenecks_family","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/identify_bottlenecks_family.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Identify bottlenecks by parameter stats::family(medians within families) — identify_bottlenecks_family","text":"Derived: slow_node_time = ess_threshold / CE_med  (seconds target; high = worse), meet_target    = slow_node_time <= runtime_s. Families degenerate metrics (non-finite non-positive) listed degenerate excluded rankings. pass sampler_params, parameters belonging names used form families.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/merge_mcmc_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge res$samples and res$samples2 into a single mcmc.list — merge_mcmc_samples","title":"Merge res$samples and res$samples2 into a single mcmc.list — merge_mcmc_samples","text":"Merge res$samples res$samples2 single mcmc.list","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/merge_mcmc_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge res$samples and res$samples2 into a single mcmc.list — merge_mcmc_samples","text":"","code":"merge_mcmc_samples(res)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/normalize_constants_generic.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize constants in a model-agnostic way — normalize_constants_generic","title":"Normalize constants in a model-agnostic way — normalize_constants_generic","text":"Normalize constants model-agnostic way","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/normalize_constants_generic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize constants in a model-agnostic way — normalize_constants_generic","text":"","code":"normalize_constants_generic(   Const,   n_rule = \"min\",   pad_rule = \"repeat_last\",   trim_rule = TRUE )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/normalize_constants_generic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize constants in a model-agnostic way — normalize_constants_generic","text":"Const list constants n_rule \"min\"|\"nyear\"|\"max\" pad_rule \"repeat_last\"|\"zero\"|\"NA\" trim_rule logical (garder TRUE)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/normalize_constants_generic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalize constants in a model-agnostic way — normalize_constants_generic","text":"constants list normalized (integer 'n')","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_bottlenecks.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot MCMC Bottlenecks by Node or Family — plot_bottlenecks","title":"Plot MCMC Bottlenecks by Node or Family — plot_bottlenecks","text":"Generates comprehensive diagnostic panel MCMC bottlenecks using efficiency convergence metrics computed per node node family. function can optionally restrict analyses nodes effectively sampled (.e. associated samplers NIMBLE configuration), identified automatically via conf.mcmc$getSamplers(). produces publication-ready figures : Median Algorithmic Efficiency (AE = ESS/iter) node family; Median Computational Efficiency (CE = ESS/s) node family; Worst targets CE (lowest ESS/s); Median worst \\(\\hat{R}\\) (Gelman–Rubin) node family. function saves plot PDF PNG specified output directory. Bar widths spacing optimized compact presentation.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_bottlenecks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot MCMC Bottlenecks by Node or Family — plot_bottlenecks","text":"","code":"plot_bottlenecks(   diag_tbl,   out_dir = \"outputs/diagnostics\",   top_k = 20L,   rhat_ref = 1.05,   sampled_only = FALSE,   conf.mcmc = NULL,   samples_ml = NULL,   make_esss_targets = TRUE,   make_esss_families = TRUE,   make_time_families = TRUE,   make_rhat_hist_targets = TRUE,   make_rhat_worst_targets = TRUE,   make_rhat_median_families = TRUE,   make_hist_ae_families = FALSE,   make_hist_ce_families = FALSE )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_bottlenecks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot MCMC Bottlenecks by Node or Family — plot_bottlenecks","text":"diag_tbl data.frame tibble containing diagnostics per target node. Must include columns target, Family, ESS, ESS_per_sec, optionally Rhat. out_dir Character string; path output directory saving figures (default: \"outputs/diagnostics\"). created recursively missing. top_k Integer; number worst best nodes display (default: 20L). rhat_ref Numeric; reference threshold Gelman–Rubin \\(\\hat{R}\\) (default: 1.05). sampled_only Logical; TRUE, restricts plots nodes explicit sampler conf.mcmc present samples_ml. Default: FALSE. conf.mcmc NIMBLE MCMC configuration object, typically produced configureMCMC(model, ...) stored build_fn()$conf. Used extract sampler-attached target nodes sampled_only = TRUE. samples_ml Optional MCMC list (returned runMCMC(..., nchains > 1)), used match sampler targets actual sample column names. make_esss_targets Logical; TRUE, produces barplot worst targets computational efficiency (default: TRUE). make_esss_families Logical; TRUE, produces barplot median algorithmic efficiency (AE) node family (default: TRUE). make_time_families Logical; TRUE, produces barplot median computational efficiency (CE) node family (default: TRUE). make_rhat_hist_targets Logical; TRUE, produces barplot median Rhat per family (default: TRUE). make_rhat_worst_targets Logical; TRUE, produces barplot worst Rhat targets (default: TRUE). make_rhat_median_families Logical; TRUE, produces alias median Rhat--family plot (default: TRUE).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_bottlenecks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot MCMC Bottlenecks by Node or Family — plot_bottlenecks","text":"Invisibly returns named list ggplot objects: bar_family_algorithmic_eff — Median AE family; bar_family_computational_eff — Median CE family; bar_target_CE — Worst targets CE; rhat_family_template — Median Rhat family; rhat_worst_targets — Worst targets Rhat. plot also saved out_dir .pdf .png.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_bottlenecks.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot MCMC Bottlenecks by Node or Family — plot_bottlenecks","text":"function core visualization tool diagnosing performance bottlenecks large hierarchical Bayesian models (e.g., SAM-like GEREM-type stock assessment models). integrates runtime, efficiency, convergence metrics standardized panel plots, suitable benchmarking, model comparison, publication figures. sampled_only = TRUE, automatically extracts list stochastic nodes (targets) conf.mcmc$getSamplers() intersects variable names present samples_ml. ensures stochastically sampled nodes visualized, excluding lifted deterministic intermediates.","code":""},{"path":[]},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_bottlenecks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot MCMC Bottlenecks by Node or Family — plot_bottlenecks","text":"","code":"if (FALSE) { # \\dontrun{ # Example assuming an existing NIMBLE configuration and MCMC results: res <- plot_bottlenecks(   diag_tbl     = diag_tbl,   conf.mcmc    = conf.mcmc,   samples_ml   = samples_ml,   sampled_only = TRUE,   out_dir      = \"outputs/diagnostics\" ) } # }"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_bottlenecks_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot diagnostics for stochastic sampler targets (strict) + all-nodes panels — plot_bottlenecks_index","title":"Plot diagnostics for stochastic sampler targets (strict) + all-nodes panels — plot_bottlenecks_index","text":"Sampler-core: strictly restrict AE/CE (related \"sampled\" panels) targets MCMC sampler, discovered inside via conf.mcmc$getSamplers() (attr(diag_tbl,\"mcmc_conf\"), explicit attr(diag_tbl,\"sampled_targets\")). \"Family\" logic anywhere. -nodes replacements (change): replace former sampled-panels listed -nodes counterparts metrics: AE median Target — nodes (steelblue) CE median Target — nodes (green) Worst CE — nodes (grey60 + labels) Top Time — nodes (grey40 + labels)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_bottlenecks_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot diagnostics for stochastic sampler targets (strict) + all-nodes panels — plot_bottlenecks_index","text":"","code":"plot_bottlenecks_index(   diag_tbl,   out_dir = \"outputs/diagnostics\",   top_k = 20L,   n_worst = 20L,   bins = 30L,   rhat_ref = 1.05,   make_bar_ae_median_all = TRUE,   make_bar_ce_median_all = TRUE,   make_bar_ce_worst_all = TRUE,   make_bar_rhat_worst = TRUE,   make_bar_ess_q5 = TRUE,   make_hist_ce = TRUE,   make_hist_ae = TRUE )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_bottlenecks_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot diagnostics for stochastic sampler targets (strict) + all-nodes panels — plot_bottlenecks_index","text":"diag_tbl data.frame per-target diagnostics; must contain target rownames. Expected: AE (AE_ESS_per_it AE), CE (ESS_per_sec ess_per_s CE); optional ESS/ess, time_s, Rhat. out_dir Output directory figures (PDF + PNG). Default: \"outputs/diagnostics\". top_k Bars shown “worst/top” -nodes panels. Default: 20L. n_worst Rows returned worst tables. Default: 20L. bins Kept API compatibility (AE/CE “hist” barplots). Default: 30L. rhat_ref Rhat reference (Rhat-1 axis). Default: 1.05. make_bar_ae_median_all, make_bar_ce_median_all, make_bar_ce_worst_all, make_bar_time_top_all Toggles -nodes panels (default TRUE). make_bar_rhat_worst, make_bar_ess_q5, make_hist_ce, make_hist_ae Toggles existing sampled-panels (default TRUE).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_bottlenecks_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot diagnostics for stochastic sampler targets (strict) + all-nodes panels — plot_bottlenecks_index","text":"Invisibly, list ggplot objects worst-node tables.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_convergence_checks.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot convergence diagnostics (R-hat & traces) with family-level R-hat bars — plot_convergence_checks","title":"Plot convergence diagnostics (R-hat & traces) with family-level R-hat bars — plot_convergence_checks","text":"ECDF plots removed. requested items produced saved.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_convergence_checks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot convergence diagnostics (R-hat & traces) with family-level R-hat bars — plot_convergence_checks","text":"","code":"plot_convergence_checks(   samples,   out_dir = \"outputs/diagnostics\",   top_k_rhat = 12L,   top_k_aelow = 12L,   runtime_s = NULL,   rhat_ref = 1.05,   make_rhat_hist = TRUE,   make_traces_rhat = TRUE,   make_traces_ae = TRUE,   make_rhat_family_bars = TRUE )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_convergence_checks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot convergence diagnostics (R-hat & traces) with family-level R-hat bars — plot_convergence_checks","text":"samples coda::mcmc.list. out_dir Output directory (PDF & PNG). top_k_rhat Number targets \"worst R-hat\" traces. top_k_aelow Number targets \"worst AE (low ESS/s)\" traces. runtime_s Total runtime seconds (optional; used compute CE needed). rhat_ref Reference R-hat threshold (default 1.01). make_rhat_hist Logical – global R-hat histogram. make_traces_rhat Logical – traces/densities worst R-hat. make_traces_ae Logical – traces/densities worst AE (low ESS/s). make_rhat_family_bars Logical – bars median R-hat family.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_convergence_checks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot convergence diagnostics (R-hat & traces) with family-level R-hat bars — plot_convergence_checks","text":"(Invisibly) list created ggplots/tables.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_family_ess_bar.html","id":null,"dir":"Reference","previous_headings":"","what":"Family-level ESS bar plot (harmonised style) — plot_family_ess_bar","title":"Family-level ESS bar plot (harmonised style) — plot_family_ess_bar","text":"Builds bar plot median ESS family dashed horizontal line 5% quantile. style mirrors example provided (fill, labels, themes, rotations).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_family_ess_bar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Family-level ESS bar plot (harmonised style) — plot_family_ess_bar","text":"","code":"plot_family_ess_bar(   samples,   runtime_s,   sampler_params = NULL,   model = NULL,   mcmc_conf = NULL,   samplers_df = NULL,   ignore_patterns = c(\"^lifted_\", \"^logProb_\"),   strict_sampler_only = TRUE )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_family_ess_bar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Family-level ESS bar plot (harmonised style) — plot_family_ess_bar","text":"samples mcmc.list/mcmc/data.frame/matrix runtime_s numeric(1) total runtime seconds (used compute CE/AE needed elsewhere) sampler_params optional character() keep sampler-attached parameters","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_family_ess_bar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Family-level ESS bar plot (harmonised style) — plot_family_ess_bar","text":"ggplot object","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_family_rhat_bar.html","id":null,"dir":"Reference","previous_headings":"","what":"Family-level Rhat bar plot (harmonised style) — plot_family_rhat_bar","title":"Family-level Rhat bar plot (harmonised style) — plot_family_rhat_bar","text":"Plots median(Rhat) family y-axis transformed median_Rhat - 1, standard convergence threshold 1.05 appears 0.05 axis.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_family_rhat_bar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Family-level Rhat bar plot (harmonised style) — plot_family_rhat_bar","text":"","code":"plot_family_rhat_bar(   samples,   runtime_s,   sampler_params = NULL,   model = NULL,   mcmc_conf = NULL,   samplers_df = NULL,   ignore_patterns = c(\"^lifted_\", \"^logProb_\"),   strict_sampler_only = TRUE,   rhat_threshold = 1.05 )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_family_rhat_bar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Family-level Rhat bar plot (harmonised style) — plot_family_rhat_bar","text":"samples mcmc.list/mcmc/data.frame/matrix runtime_s numeric(1) total runtime seconds sampler_params optional character() keep sampler-attached parameters rhat_threshold numeric(1) convergence threshold (default 1.05)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_family_rhat_bar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Family-level Rhat bar plot (harmonised style) — plot_family_rhat_bar","text":"ggplot object (NULL finite Rhat values)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_mcmc_histograms.html","id":null,"dir":"Reference","previous_headings":"","what":"Histograms for ESS / CE / AE / Rhat (ggplot2) — plot_mcmc_histograms","title":"Histograms for ESS / CE / AE / Rhat (ggplot2) — plot_mcmc_histograms","text":"Histograms ESS / CE / AE / Rhat (ggplot2)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/plot_mcmc_histograms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Histograms for ESS / CE / AE / Rhat (ggplot2) — plot_mcmc_histograms","text":"","code":"plot_mcmc_histograms(   samples,   runtime_s,   rhat_thresh = 1.01,   bins = 30,   log_x = TRUE )"},{"path":[]},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/profile_sampler_times.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Profile sampler times per node/family — profile_sampler_times","text":"","code":"profile_sampler_times(   model,   conf,   niter = 2000L,   burnin = 500L,   thin = 1L,   set_seed = NULL,   progress = FALSE )  profile_sampler_times(   model,   conf,   niter = 2000L,   burnin = 500L,   thin = 1L,   set_seed = NULL,   progress = FALSE )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/profile_sampler_times.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Profile sampler times per node/family — profile_sampler_times","text":"model nimbleModel (uncompiled), initialized. conf MCMC configuration nimble::configureMCMC(model, ...). niter Total iterations including burn-. burnin Number warm-iterations timing. thin Thinning interval (\\(\\ge\\) 1). > 1, extra sweeps advanced without timing. set_seed Integer NULL; NULL, set.seed() reproducibility. progress Logical; print simple 10\\ cmodelA compiled nimbleModel. mcmc_confAn MCMC configuration (e.g., nimble::configureMCMC(model)). NULL, automatic attempt made. include_dataLogical; include data nodes (default FALSE). removed_nodesCharacter vector; nodes exclude (e.g., ESS = 0). ignore_patternsCharacter vector; regex ignore (default c(\"^lifted_\", \"^logProb_\")). plot_dependenciesLogical; TRUE, barplot (ggplot2) medians per family. output_dirCharacter NULL; directory CSV/PNG exports (NULL = export). save_csvLogical; TRUE, write dependencies_per_node.csv output_dir. node_of_interestCharacter NULL; node whose filtered downstream deps requested. npNumeric (0,1]; proportion prop_worst = ceil(n_samplers * np) (default 0.10). ...Additional arguments passed nimble::configureMCMC() (e.g., print = FALSE, useConjugacy = FALSE). list (least) data frames per node/family (optionally) ggplot objects.list:","code":"(stochastic_nodes, deterministic_nodes, dims, nodes = NULL,    dependencies_df, dep_counts, dep_summary, plot_regular,    node_of_interest_deps,    samplers_df, n_samplers, prop_worst,    mcmc_conf)  # configuration created internally"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/proxy_step_sd.html","id":null,"dir":"Reference","previous_headings":"","what":"Step proxy: sd(diff(chain)) on columns matching a pattern — proxy_step_sd","title":"Step proxy: sd(diff(chain)) on columns matching a pattern — proxy_step_sd","text":"Computes, parameter whose name matches pattern, standard deviation successive differences (simple step-size proxy).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/proxy_step_sd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Step proxy: sd(diff(chain)) on columns matching a pattern — proxy_step_sd","text":"","code":"proxy_step_sd(samples, pattern)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/proxy_step_sd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Step proxy: sd(diff(chain)) on columns matching a pattern — proxy_step_sd","text":"samples coda::mcmc.list. pattern string; pattern match column names (fixed match).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/proxy_step_sd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Step proxy: sd(diff(chain)) on columns matching a pattern — proxy_step_sd","text":"named numeric vector giving sd(diff(.)) per parameter.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/run_baseline_coda.html","id":null,"dir":"Reference","previous_headings":"","what":"Run baseline et retourne un mcmc.list fusionne (samples + samples2) — run_baseline_coda","title":"Run baseline et retourne un mcmc.list fusionne (samples + samples2) — run_baseline_coda","text":"Run baseline et retourne un mcmc.list fusionne (samples + samples2)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/run_baseline_coda.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run baseline et retourne un mcmc.list fusionne (samples + samples2) — run_baseline_coda","text":"","code":"run_baseline_coda(   build_fn,   niter,   nburnin = floor(0.25 * niter),   thin = 1L,   monitors = NULL,   nchains = 1L,   drop_loglik = FALSE,   opts = samOptiPro_options() )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/run_baseline_config.html","id":null,"dir":"Reference","previous_headings":"","what":"Run baseline RW/Slice with robust compile/run — run_baseline_config","title":"Run baseline RW/Slice with robust compile/run — run_baseline_config","text":"Run baseline RW/Slice robust compile/run","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/run_baseline_config.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run baseline RW/Slice with robust compile/run — run_baseline_config","text":"","code":"run_baseline_config(   build_fn,   niter,   nburnin = floor(0.25 * niter),   thin = 1L,   monitors = NULL,   nchains = 1L,   opts = samOptiPro_options() )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/run_hmc_all_nodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Run HMC/NUTS where possible; fallback samplers for uncovered nodes — run_hmc_all_nodes","title":"Run HMC/NUTS where possible; fallback samplers for uncovered nodes — run_hmc_all_nodes","text":"Run HMC/NUTS possible; fallback samplers uncovered nodes","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/run_hmc_all_nodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run HMC/NUTS where possible; fallback samplers for uncovered nodes — run_hmc_all_nodes","text":"","code":"run_hmc_all_nodes(   build_fn,   niter,   nburnin = floor(0.25 * niter),   thin = 1L,   monitors = NULL,   nchains = 1L,   opts = samOptiPro_options() )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/run_structure_and_hmc_test.html","id":null,"dir":"Reference","previous_headings":"","what":"Run structural diagnostics and (optional) HMC/NUTS smoke test — run_structure_and_hmc_test","title":"Run structural diagnostics and (optional) HMC/NUTS smoke test — run_structure_and_hmc_test","text":"Inspects NIMBLE model produced build_fn() : count stochastic vs. deterministic nodes (optionally including data), parse model code detect non-differentiable functions BUGS-style truncation, rebuild per-node table distribution, support, bounds, tag HMC showstoppers (e.g., discrete latents, simplex constraints, truncation, non-differentiable deterministic ops feeding latents), optionally attempt short HMC/NUTS run (via nimbleHMC) check practical feasibility.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/run_structure_and_hmc_test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run structural diagnostics and (optional) HMC/NUTS smoke test — run_structure_and_hmc_test","text":"","code":"run_structure_and_hmc_test(   build_fn,   include_data = FALSE,   try_hmc = TRUE,   niter = 50L,   nburnin = 10L,   seed = 1L )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/run_structure_and_hmc_test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run structural diagnostics and (optional) HMC/NUTS smoke test — run_structure_and_hmc_test","text":"build_fn zero-arg function returning list least model (nimbleModel); optional elements: cmodel, monitors, code_text (code) used strengthen non-diff detection. include_data Logical; include data nodes counts scans. Default FALSE. try_hmc Logical; TRUE, attempt brief HMC/NUTS run. Default TRUE. niter Integer; total iterations HMC test. Default 50L. nburnin Integer; burn-HMC test. Default 10L. seed Integer; RNG seed HMC run. Default 1L.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/run_structure_and_hmc_test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run structural diagnostics and (optional) HMC/NUTS smoke test — run_structure_and_hmc_test","text":"invisible list components: diag: list nodes (data.frame node metadata HMC showstopper tags), nondiff_signals, code_scan, hmc_globally_ok. hmc: list describing HMC trial (ok, error, details).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/run_structure_and_hmc_test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run structural diagnostics and (optional) HMC/NUTS smoke test — run_structure_and_hmc_test","text":"Compared diagnose_model_structure(), function filter nodes ignore patterns explicit removals compute dependency fan-. emphasis HMC suitability rather structural load.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/run_structure_and_hmc_test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run structural diagnostics and (optional) HMC/NUTS smoke test — run_structure_and_hmc_test","text":"","code":"if (FALSE) { # \\dontrun{ out <- run_structure_and_hmc_test(my_builder, include_data = FALSE, try_hmc = TRUE) if (!out$hmc$ok) message(\"HMC not feasible: \", out$hmc$error) } # } run_structure_and_hmc_test #> function (build_fn, include_data = FALSE, try_hmc = TRUE, niter = 50L,  #>     nburnin = 10L, seed = 1L)  #> { #>     `%||%` <- function(a, b) if (is.null(a))  #>         b #>     else a #>     to_logical <- function(x) { #>         if (is.logical(x))  #>             return(x) #>         if (is.numeric(x))  #>             return(x != 0) #>         if (is.factor(x))  #>             x <- as.character(x) #>         if (is.character(x)) { #>             y <- tolower(trimws(x)) #>             return(y %in% c(\"true\", \"t\", \"1\", \"yes\", \"y\")) #>         } #>         rep(FALSE, length(x)) #>     } #>     strip_index <- function(x) sub(\"\\\\[.*\\\\]$\", \"\", x) #>     normalize_dist <- function(d) { #>         d <- tolower(trimws(d %||% \"\")) #>         if (d == \"\")  #>             return(NA_character_) #>         d <- sub(\"^dbernoulli$\", \"dbern\", d) #>         d <- sub(\"^dbin$\", \"dbinom\", d) #>         d <- sub(\"^dmulti$\", \"dmultinom\", d) #>         d <- sub(\"^dnbinom$\", \"dnegbin\", d) #>         d <- sub(\"^ddirich(let)?$\", \"ddirichlet\", d) #>         d <- sub(\"^ddirch(let)?$\", \"ddirichlet\", d) #>         d <- sub(\"^dhyperg(eometric)?$\", \"dhypergeom\", d) #>         d <- sub(\"^dhyper$\", \"dhypergeom\", d) #>         d <- sub(\"^dpois_rate$\", \"dpois\", d) #>         d <- sub(\"^dtri(angle)?$\", \"dtriangle\", d) #>         d <- sub(\"^dhalfnorm(al)?$\", \"dhalfnorm\", d) #>         d <- sub(\"^dhalfcauchy$\", \"dhalfcauchy\", d) #>         d #>     } #>     discrete_dists <- c(\"dbern\", \"dbinom\", \"dcat\", \"dmultinom\",  #>         \"dgeom\", \"dnegbin\", \"dpois\", \"dhypergeom\", \"dinterval\") #>     simplex_dists <- c(\"ddirichlet\") #>     bounded_support_dists <- c(\"dbeta\", \"dunif\", \"dtriangle\",  #>         \"dhalfnorm\", \"dhalfcauchy\") #>     support_of <- function(dist_name, lb, ub) { #>         d <- normalize_dist(dist_name) #>         if (is.na(d))  #>             return(\"unknown\") #>         if (d %in% discrete_dists)  #>             return(\"discrete\") #>         if (d %in% simplex_dists)  #>             return(\"simplex\") #>         if (d %in% bounded_support_dists)  #>             return(\"bounded-continuous\") #>         \"continuous\" #>     } #>     .sop_supports_derivs <- function(model) { #>         bd1 <- try(model$modelDef$buildDerivs, silent = TRUE) #>         if (!inherits(bd1, \"try-error\") && !is.null(bd1))  #>             return(isTRUE(bd1)) #>         bd2 <- try(model$buildDerivs, silent = TRUE) #>         if (!inherits(bd2, \"try-error\") && !is.null(bd2))  #>             return(isTRUE(bd2)) #>         if (requireNamespace(\"nimbleHMC\", quietly = TRUE)) { #>             conf <- try(nimble::configureMCMC(model), silent = TRUE) #>             if (!inherits(conf, \"try-error\")) { #>                 ok <- TRUE #>                 tryCatch({ #>                   nimbleHMC::configureHMC(conf, model = model) #>                 }, error = function(e) { #>                   msg <- tolower(conditionMessage(e)) #>                   if (grepl(\"deriv\", msg) || grepl(\"buildderiv\",  #>                     msg))  #>                     ok <<- FALSE #>                 }) #>                 return(ok) #>             } #>         } #>         FALSE #>     } #>     stopifnot(is.function(build_fn)) #>     parts <- build_fn() #>     m <- parts$model #>     cm <- parts$cmodel %||% NULL #>     mons <- parts$monitors %||% character(0) #>     code_override <- parts$code_text %||% parts$code %||% NULL #>     if (!is.null(code_override) && !is.character(code_override)) { #>         code_override <- try(paste(deparse(code_override), collapse = \"\\n\"),  #>             silent = TRUE) #>         if (inherits(code_override, \"try-error\"))  #>             code_override <- NULL #>     } #>     cat(\"\\n[STRUCTURE]\\n\") #>     cat(sprintf(\"- # stochastic nodes   : %d\\n\", length(m$getNodeNames(stochOnly = TRUE,  #>         includeData = include_data)))) #>     cat(sprintf(\"- # deterministic nodes: %d\\n\", length(m$getNodeNames(stochOnly = FALSE,  #>         includeData = include_data)) - length(m$getNodeNames(stochOnly = TRUE,  #>         includeData = include_data)))) #>     .sop_detect_nondiff_functions <- function(model, nondiff_candidates = c(\"round\",  #>         \"floor\", \"ceiling\", \"trunc\", \"abs\", \"max\", \"min\", \"step\",  #>         \"ifElse\", \"ifelse\", \"equals\"), code_text_override = NULL) { #>         out <- character(0) #>         code_txt <- \"\" #>         if (is.character(code_text_override) && length(code_text_override)) { #>             code_txt <- paste(code_text_override, collapse = \"\\n\") #>         } #>         else { #>             code_try <- try({ #>                 code_txt <- paste0(paste(deparse(model$modelDef$code,  #>                   width.cutoff = 500), collapse = \"\\n\"), \"\\n\") #>             }, silent = TRUE) #>             if (inherits(code_try, \"try-error\") || is.null(code_txt) ||  #>                 nchar(code_txt) == 0) { #>                 code_txt <- tryCatch(paste(utils::capture.output(print(model)),  #>                   collapse = \"\\n\"), error = function(e) \"\") #>             } #>         } #>         if (nchar(code_txt)) { #>             for (fn in nondiff_candidates) { #>                 pat1 <- paste0(\"\\\\b\", fn, \"\\\\s*\\\\(\") #>                 pat2 <- paste0(\"(?i)\\\\b\", fn, \"\\\\s*\\\\(\") #>                 if (grepl(pat1, code_txt, perl = TRUE) || grepl(pat2,  #>                   code_txt, perl = TRUE))  #>                   out <- c(out, fn) #>             } #>         } #>         pull_char <- function(x) { #>             x <- try(x, silent = TRUE) #>             if (inherits(x, \"try-error\") || is.null(x))  #>                 return(character(0)) #>             as.character(unlist(x, use.names = FALSE)) #>         } #>         maps <- try(model$modelDef$maps, silent = TRUE) #>         if (!inherits(maps, \"try-error\") && !is.null(maps)) { #>             out <- c(out, pull_char(maps$nodeFxnNames)) #>             out <- c(out, pull_char(maps$allFxnNames)) #>             out <- c(out, pull_char(maps$fxnNamesByNode)) #>             out <- c(out, pull_char(maps$deterministicFxnNames)) #>         } #>         out <- unique(tolower(out)) #>         hits <- intersect(out, tolower(nondiff_candidates)) #>         list(hits = hits, code_txt = code_txt) #>     } #>     nd <- .sop_detect_nondiff_functions(m, code_text_override = code_override) #>     nondiff_hits <- nd$hits #>     code_txt_scanned <- nd$code_txt #>     truncation_detected_bugst <- grepl(\"\\\\)\\\\s*T\\\\s*\\\\(\", code_txt_scanned,  #>         perl = TRUE) #>     dists_in_code_raw <- unique(tolower(unlist(regmatches(code_txt_scanned,  #>         gregexpr(\"\\\\bd[a-zA-Z_]+\\\\b\", code_txt_scanned, perl = TRUE))))) #>     dists_in_code <- unique(vapply(dists_in_code_raw, normalize_dist,  #>         character(1))) #>     diag_raw <- try(diagnose_model_structure(m, include_data = include_data),  #>         silent = TRUE) #>     rebuild_nodes_df <- function(model, include_data) { #>         all_nodes <- model$getNodeNames(includeData = include_data) #>         stoch <- model$getNodeNames(stochOnly = TRUE, includeData = include_data) #>         is_data_vec <- stats::setNames(rep(FALSE, length(all_nodes)),  #>             all_nodes) #>         for (n in all_nodes) is_data_vec[n] <- tryCatch(model$isData(n),  #>             error = function(e) FALSE) #>         get_dist_raw <- function(node) tolower(tryCatch(model$getDistribution(node),  #>             error = function(e) NA_character_)) #>         get_bound <- function(node, side) suppressWarnings(tryCatch(model$getBound(node,  #>             side), error = function(e) NA_real_)) #>         nodes_df <- do.call(rbind, lapply(all_nodes, function(node) { #>             is_stoch <- node %in% stoch #>             dist_raw <- if (is_stoch)  #>                 get_dist_raw(node) #>             else NA_character_ #>             dist <- if (is_stoch)  #>                 normalize_dist(dist_raw) #>             else NA_character_ #>             lb <- if (is_stoch)  #>                 get_bound(node, \"lower\") #>             else NA_real_ #>             ub <- if (is_stoch)  #>                 get_bound(node, \"upper\") #>             else NA_real_ #>             sup <- if (is_stoch)  #>                 support_of(dist, lb, ub) #>             else NA_character_ #>             data.frame(node = node, var = strip_index(node),  #>                 is_stoch = is_stoch, is_data = is_data_vec[[node]],  #>                 dist_raw = dist_raw, dist = dist, support = sup,  #>                 lower = lb, upper = ub, stringsAsFactors = FALSE) #>         })) #>         nodes_df$var <- as.character(nodes_df$var) #>         nodes_df$is_stoch <- to_logical(nodes_df$is_stoch) #>         nodes_df$is_data <- to_logical(nodes_df$is_data) #>         fin_lb <- is.finite(as.numeric(nodes_df$lower)) #>         fin_ub <- is.finite(as.numeric(nodes_df$upper)) #>         trunc_by_bounds <- nodes_df$is_stoch & (nodes_df$support ==  #>             \"continuous\") & fin_lb & fin_ub #>         nodes_df$is_truncated <- trunc_by_bounds | (nodes_df$is_stoch &  #>             isTRUE(truncation_detected_bugst)) #>         nodes_df$hmc_showstopper_reason <- NA_character_ #>         nodes_df$hmc_showstopper_reason[nodes_df$is_stoch & !nodes_df$is_data &  #>             nodes_df$support == \"discrete\"] <- \"discrete-latent\" #>         nodes_df$hmc_showstopper_reason[nodes_df$is_stoch & !nodes_df$is_data &  #>             nodes_df$support == \"simplex\" & is.na(nodes_df$hmc_showstopper_reason)] <- \"simplex-constraint\" #>         nodes_df$hmc_showstopper_reason[nodes_df$is_stoch & !nodes_df$is_data &  #>             nodes_df$is_truncated & is.na(nodes_df$hmc_showstopper_reason)] <- \"truncation\" #>         if (length(nondiff_hits)) { #>             nodes_df$hmc_showstopper_reason[!nodes_df$is_stoch &  #>                 is.na(nodes_df$hmc_showstopper_reason)] <- \"non-diff-deterministic-op\" #>         } #>         vars <- unique(nodes_df$var) #>         dims <- lapply(vars, function(v) { #>             vi <- tryCatch(model$getVarInfo(v), error = function(e) NULL) #>             if (is.null(vi) || is.null(vi$nDim))  #>                 NA_integer_ #>             else as.integer(vi$nDim) #>         }) #>         names(dims) <- vars #>         nodes_df$dims <- unname(vapply(nodes_df$var, function(v) { #>             if (v %in% names(dims))  #>                 dims[[v]] #>             else NA_integer_ #>         }, integer(1))) #>         nodes_df #>     } #>     nodes <- if (!inherits(diag_raw, \"try-error\") && is.list(diag_raw) &&  #>         is.data.frame(diag_raw$nodes)) { #>         nds <- diag_raw$nodes #>         if (\"dist\" %in% names(nds))  #>             nds$dist <- vapply(nds$dist, normalize_dist, character(1)) #>         if (\"dist_raw\" %in% names(nds))  #>             nds$dist_raw <- tolower(nds$dist_raw) #>         nds$var <- as.character(nds$var) #>         nds$is_stoch <- to_logical(nds$is_stoch) #>         nds$is_data <- to_logical(nds$is_data %||% FALSE) #>         fin_lb <- is.finite(as.numeric(nds$lower %||% NA_real_)) #>         fin_ub <- is.finite(as.numeric(nds$upper %||% NA_real_)) #>         trunc_by_bounds <- nds$is_stoch & (mapply(support_of,  #>             nds$dist, nds$lower, nds$upper, SIMPLIFY = TRUE) ==  #>             \"continuous\") & fin_lb & fin_ub #>         nds$is_truncated <- trunc_by_bounds | (nds$is_stoch &  #>             isTRUE(truncation_detected_bugst)) #>         nds$support <- mapply(support_of, nds$dist, nds$lower,  #>             nds$upper, SIMPLIFY = TRUE, USE.NAMES = FALSE) #>         if (!\"hmc_showstopper_reason\" %in% names(nds))  #>             nds$hmc_showstopper_reason <- NA_character_ #>         nds$hmc_showstopper_reason[nds$is_stoch & !nds$is_data &  #>             nds$support == \"discrete\"] <- \"discrete-latent\" #>         nds$hmc_showstopper_reason[nds$is_stoch & !nds$is_data &  #>             nds$support == \"simplex\" & is.na(nds$hmc_showstopper_reason)] <- \"simplex-constraint\" #>         nds$hmc_showstopper_reason[nds$is_stoch & !nds$is_data &  #>             nds$is_truncated & is.na(nds$hmc_showstopper_reason)] <- \"truncation\" #>         if (length(nondiff_hits)) { #>             nds$hmc_showstopper_reason[!nds$is_stoch & is.na(nds$hmc_showstopper_reason)] <- \"non-diff-deterministic-op\" #>         } #>         if (!\"dims\" %in% names(nds)) { #>             vars <- unique(nds$var) #>             dims <- lapply(vars, function(v) { #>                 vi <- tryCatch(m$getVarInfo(v), error = function(e) NULL) #>                 if (is.null(vi) || is.null(vi$nDim))  #>                   NA_integer_ #>                 else as.integer(vi$nDim) #>             }) #>             names(dims) <- vars #>             nds$dims <- unname(vapply(nds$var, function(v) { #>                 if (v %in% names(dims))  #>                   dims[[v]] #>                 else NA_integer_ #>             }, integer(1))) #>         } #>         nds #>     } #>     else { #>         rebuild_nodes_df(m, include_data) #>     } #>     cat(\"\\n[NON-DIFF INDICATORS]\\n\") #>     cat(sprintf(\"- Non-diff functions detected: %s\\n\", if (length(nondiff_hits))  #>         paste(nondiff_hits, collapse = \",\") #>     else \"None\")) #>     cat(sprintf(\"- Distributions found in code : %s\\n\", if (length(dists_in_code))  #>         paste(sort(unique(dists_in_code)), collapse = \", \") #>     else \"None\")) #>     bounded_latent_trunc <- any(nodes$is_stoch & !nodes$is_data &  #>         (nodes$support == \"continuous\") & is.finite(nodes$lower) &  #>         is.finite(nodes$upper), na.rm = TRUE) #>     cat(sprintf(\"- BUGS-style truncation 'T(a,b)' spotted: %s\\n\",  #>         if (isTRUE(truncation_detected_bugst))  #>             \"Yes\" #>         else \"No\")) #>     cat(sprintf(\"- Bounded latent nodes (implicit truncation via finite bounds on continuous support): %s\\n\",  #>         if (bounded_latent_trunc)  #>             \"Yes\" #>         else \"No\")) #>     if (length(nondiff_hits)) { #>         code_lines <- unlist(strsplit(code_txt_scanned, \"\\n\",  #>             fixed = TRUE)) #>         round_lines <- grep(\"\\\\bround\\\\s*\\\\(\", code_lines, value = TRUE,  #>             perl = TRUE) #>         vars_in_lines <- unique(gsub(\"\\\\[.*?\\\\]$\", \"\", unlist(regmatches(round_lines,  #>             gregexpr(\"\\\\b[A-Za-z_][A-Za-z0-9_]*(\\\\[[^\\\\]]+\\\\])?\",  #>                 round_lines, perl = TRUE))))) #>         vars_in_model <- unique(nodes$var) #>         seed_vars <- intersect(vars_in_lines, vars_in_model) #>         latents <- nodes$node[nodes$is_stoch & !nodes$is_data] #>         det_anc_all <- unique(unlist(lapply(latents, function(nd) tryCatch(m$getDependencies(target = nd,  #>             upstream = TRUE, downstream = FALSE, includeData = FALSE,  #>             stochOnly = FALSE), error = function(e) character(0))))) #>         det_anc_vars <- gsub(\"\\\\[.*?\\\\]$\", \"\", det_anc_all) #>         to_tag <- det_anc_all[det_anc_vars %in% seed_vars] #>         is_det <- !nodes$is_stoch #>         nodes$hmc_showstopper_reason[is_det] <- ifelse(nodes$node[is_det] %in%  #>             to_tag, \"non-diff-deterministic-op\", NA_character_) #>     } #>     cat(\"\\n[DEBUG before summarise_showstoppers]\\n\") #>     cat(\"has hmc_showstopper_reason? \", \"hmc_showstopper_reason\" %in%  #>         names(nodes), \"\\n\") #>     if (\"hmc_showstopper_reason\" %in% names(nodes)) { #>         cat(\"non-NA reasons (non-data): \", sum(!nodes$is_data &  #>             !is.na(nodes$hmc_showstopper_reason)), \"\\n\") #>         print(utils::head(nodes[!nodes$is_data & !is.na(nodes$hmc_showstopper_reason),  #>             c(\"node\", \"is_stoch\", \"hmc_showstopper_reason\")],  #>             10), row.names = FALSE) #>     } #>     summarise_showstoppers <- function(nodes_df) { #>         ss <- nodes_df #>         if (!\"hmc_showstopper_reason\" %in% names(ss))  #>             ss$hmc_showstopper_reason <- NA_character_ #>         if (!\"is_data\" %in% names(ss))  #>             ss$is_data <- FALSE #>         ss$is_data <- to_logical(ss$is_data) #>         ss <- ss[!is.na(ss$hmc_showstopper_reason) & !ss$is_data,  #>             , drop = FALSE] #>         if (!nrow(ss)) { #>             return(list(summary = data.frame(reason = character(0),  #>                 n_nodes = integer(0)), examples = data.frame(reason = character(0),  #>                 examples = character(0)))) #>         } #>         tt <- as.data.frame(table(ss$hmc_showstopper_reason),  #>             stringsAsFactors = FALSE) #>         names(tt) <- c(\"reason\", \"n_nodes\") #>         tt$n_nodes <- as.integer(tt$n_nodes) #>         tt <- tt[order(-tt$n_nodes, tt$reason), , drop = FALSE] #>         ex <- do.call(rbind, lapply(split(ss, ss$hmc_showstopper_reason),  #>             function(d) { #>                 data.frame(reason = as.character(d$hmc_showstopper_reason[1]),  #>                   examples = paste(unique(utils::head(as.character(d$node),  #>                     5)), collapse = \",\"), stringsAsFactors = FALSE) #>             })) #>         rownames(ex) <- NULL #>         list(summary = tt, examples = ex) #>     } #>     ss <- summarise_showstoppers(nodes) #>     cat(\"\\n[HMC/NUTS SHOWSTOPPERS]\\n\") #>     if (nrow(ss$summary)) { #>         print(ss$summary, row.names = FALSE) #>         cat(\"\\nExamples by reason:\\n\") #>         print(ss$examples, row.names = FALSE) #>     } #>     else { #>         reasons <- unique(stats::na.omit(nodes$hmc_showstopper_reason[!nodes$is_data])) #>         if (length(reasons)) { #>             cat(\"(no table -- fallback summary)\\n\") #>             cat(\"Reasons: \", paste(sort(reasons), collapse = \", \"),  #>                 \"\\n\", sep = \"\") #>         } #>         else { #>             cat(\"- No explicit showstoppers detected at latent nodes.\\n\") #>         } #>     } #>     hsk <- nodes$hmc_showstopper_reason %||% rep(NA_character_,  #>         nrow(nodes)) #>     hmc_globally_ok <- all(is.na(hsk[!nodes$is_data])) #>     cat(sprintf(\"\\n- HMC globally feasible? %s\\n\", if (isTRUE(hmc_globally_ok))  #>         \"Yes\" #>     else \"No\")) #>     hmc_res <- list(ok = FALSE, error = \"HMC test not requested.\",  #>         details = NULL) #>     if (isTRUE(try_hmc)) { #>         cat(\"\\n[HMC/NUTS SMOKE TEST]\\n\") #>         has_hmc <- suppressWarnings(requireNamespace(\"nimbleHMC\",  #>             quietly = TRUE)) #>         if (!has_hmc) { #>             msg <- \"nimbleHMC not available (not installed or not loaded).\" #>             cat(sprintf(\"- HMC feasible? No\\n  reason: %s\\n\",  #>                 msg)) #>             hmc_res <- list(ok = FALSE, error = msg, details = NULL) #>         } #>         else if (!isTRUE(hmc_globally_ok)) { #>             reasons <- unique(stats::na.omit(nodes$hmc_showstopper_reason[!nodes$is_data])) #>             msg <- sprintf(\"Model not suitable for HMC/NUTS (structural): %s\",  #>                 paste(reasons, collapse = \",\")) #>             cat(sprintf(\"- HMC feasible? No\\n  reason: %s\\n\",  #>                 msg)) #>             hmc_res <- list(ok = FALSE, error = msg, details = NULL) #>         } #>         else { #>             model_has_derivs <- .sop_supports_derivs(m) #>             if (!isTRUE(model_has_derivs)) { #>                 msg <- \"NUTS not attempted: the model was not built with buildDerivs=TRUE.\" #>                 cat(sprintf(\"- HMC feasible? No\\n  reason: %s\\n\",  #>                   msg)) #>                 hmc_res <- list(ok = FALSE, error = msg, details = NULL) #>             } #>             else { #>                 base_conf <- try(nimble::configureMCMC(m), silent = TRUE) #>                 if (inherits(base_conf, \"try-error\")) { #>                   msg <- paste(\"configureMCMC failed:\", as.character(base_conf)) #>                   cat(sprintf(\"- HMC feasible? No\\n  reason: %s\\n\",  #>                     msg)) #>                   hmc_res <- list(ok = FALSE, error = msg, details = NULL) #>                 } #>                 else { #>                   if (length(mons))  #>                     try(base_conf$addMonitors(mons), silent = TRUE) #>                   okH <- TRUE #>                   tryCatch({ #>                     nimbleHMC::configureHMC(base_conf, model = m) #>                   }, error = function(e) { #>                     okH <<- FALSE #>                     cat(\"configureHMC failed: \", e$message, \"\\n\",  #>                       sep = \"\") #>                   }) #>                   if (!okH) { #>                     msg <- \"configureHMC failed.\" #>                     cat(sprintf(\"- HMC feasible? No\\n  reason: %s\\n\",  #>                       msg)) #>                     hmc_res <- list(ok = FALSE, error = msg,  #>                       details = NULL) #>                   } #>                   else { #>                     mcmc <- try(nimble::buildMCMC(base_conf),  #>                       silent = TRUE) #>                     if (inherits(mcmc, \"try-error\")) { #>                       msg <- paste(\"buildMCMC failed:\", as.character(mcmc)) #>                       cat(sprintf(\"- HMC feasible? No\\n  reason: %s\\n\",  #>                         msg)) #>                       hmc_res <- list(ok = FALSE, error = msg,  #>                         details = NULL) #>                     } #>                     else { #>                       cm_obj <- if (!is.null(cm))  #>                         cm #>                       else try(nimble::compileNimble(m), silent = TRUE) #>                       cmcmc <- try(nimble::compileNimble(mcmc,  #>                         project = cm_obj, resetFunctions = TRUE),  #>                         silent = TRUE) #>                       if (inherits(cmcmc, \"try-error\")) { #>                         msg <- paste(\"compileNimble failed:\",  #>                           as.character(cmcmc)) #>                         cat(sprintf(\"- HMC feasible? No\\n  reason: %s\\n\",  #>                           msg)) #>                         hmc_res <- list(ok = FALSE, error = msg,  #>                           details = NULL) #>                       } #>                       else { #>                         set.seed(seed) #>                         run <- try(nimble::runMCMC(cmcmc, niter = as.integer(niter),  #>                           nburnin = as.integer(nburnin), thin = 1L,  #>                           nchains = 1L, samplesAsCodaMCMC = FALSE,  #>                           summary = FALSE, WAIC = FALSE), silent = TRUE) #>                         if (inherits(run, \"try-error\")) { #>                           msg <- paste(\"runMCMC failed:\", as.character(run)) #>                           cat(sprintf(\"- HMC feasible? No\\n  reason: %s\\n\",  #>                             msg)) #>                           hmc_res <- list(ok = FALSE, error = msg,  #>                             details = NULL) #>                         } #>                         else { #>                           cat(\"- HMC feasible? Yes\\n\") #>                           hmc_res <- list(ok = TRUE, error = NULL,  #>                             details = run) #>                         } #>                       } #>                     } #>                   } #>                 } #>             } #>         } #>     } #>     invisible(list(diag = list(nodes = nodes, nondiff_signals = list(functions_found = sort(unique(nondiff_hits)),  #>         distributions_found = sort(unique(dists_in_code)), distributions_found_raw = sort(unique(dists_in_code_raw)),  #>         truncation_bugst = truncation_detected_bugst, bounded_latent_trunc = bounded_latent_trunc),  #>         code_scan = code_txt_scanned, hmc_globally_ok = hmc_globally_ok),  #>         hmc = hmc_res)) #> } #> <bytecode: 0x5585a909e2b8> #> <environment: namespace:samOptiPro>"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Return a data.frame (name, type, target, scale) from a sampler container. Accepts: samplerConf list (conf$getSamplers()) or other sampler-like lists. — sampler_df","title":"Return a data.frame (name, type, target, scale) from a sampler container. Accepts: samplerConf list (conf$getSamplers()) or other sampler-like lists. — sampler_df","text":"Return data.frame (name, type, target, scale) sampler container. Accepts: samplerConf list (conf$getSamplers()) sampler-like lists.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return a data.frame (name, type, target, scale) from a sampler container. Accepts: samplerConf list (conf$getSamplers()) or other sampler-like lists. — sampler_df","text":"","code":"sampler_df(samplers)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_df_from_conf.html","id":null,"dir":"Reference","previous_headings":"","what":"Convenience: directly return sampler_df from an existing conf. — sampler_df_from_conf","title":"Convenience: directly return sampler_df from an existing conf. — sampler_df_from_conf","text":"Convenience: directly return sampler_df existing conf.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_df_from_conf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convenience: directly return sampler_df from an existing conf. — sampler_df_from_conf","text":"","code":"sampler_df_from_conf(conf)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_env_dump.html","id":null,"dir":"Reference","previous_headings":"","what":"Long data.frame of sampler env numeric fields — sampler_env_dump","title":"Long data.frame of sampler env numeric fields — sampler_env_dump","text":"Long data.frame sampler env numeric fields","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_env_dump.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Long data.frame of sampler env numeric fields — sampler_env_dump","text":"","code":"sampler_env_dump(cm)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_env_dump.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Long data.frame of sampler env numeric fields — sampler_env_dump","text":"cm compiled MCMC","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_env_dump.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Long data.frame of sampler env numeric fields — sampler_env_dump","text":"data.frame(sampler_index, field, value)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_env_numeric_fields.html","id":null,"dir":"Reference","previous_headings":"","what":"Numeric scalar fields in the environment of each compiled sampler function — sampler_env_numeric_fields","title":"Numeric scalar fields in the environment of each compiled sampler function — sampler_env_numeric_fields","text":"Numeric scalar fields environment compiled sampler function","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_env_numeric_fields.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numeric scalar fields in the environment of each compiled sampler function — sampler_env_numeric_fields","text":"","code":"sampler_env_numeric_fields(cm)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_env_numeric_fields.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Numeric scalar fields in the environment of each compiled sampler function — sampler_env_numeric_fields","text":"cm compiled MCMC (compileNimble(buildMCMC(...)))","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_env_numeric_fields.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Numeric scalar fields in the environment of each compiled sampler function — sampler_env_numeric_fields","text":"list named lists (one per sampler)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_functions_from_conf.html","id":null,"dir":"Reference","previous_headings":"","what":"Build and compile an MCMC from a conf to access samplerFunctions. — sampler_functions_from_conf","title":"Build and compile an MCMC from a conf to access samplerFunctions. — sampler_functions_from_conf","text":"Build compile MCMC conf access samplerFunctions.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_functions_from_conf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build and compile an MCMC from a conf to access samplerFunctions. — sampler_functions_from_conf","text":"","code":"sampler_functions_from_conf(conf, cmodel)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_scale.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a numeric scale proxy from a sampler object. For RW: control$scale ; For slice: control$width (returned as 'scale'). Fallbacks: $scale (numeric or function) or environment(s)$scale. — sampler_scale","title":"Extract a numeric scale proxy from a sampler object. For RW: control$scale ; For slice: control$width (returned as 'scale'). Fallbacks: $scale (numeric or function) or environment(s)$scale. — sampler_scale","text":"Extract numeric scale proxy sampler object. RW: control$scale ; slice: control$width (returned 'scale'). Fallbacks: $scale (numeric function) environment(s)$scale.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_scale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a numeric scale proxy from a sampler object. For RW: control$scale ; For slice: control$width (returned as 'scale'). Fallbacks: $scale (numeric or function) or environment(s)$scale. — sampler_scale","text":"","code":"sampler_scale(s)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_scales_after_run.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract sampler scales after a short adaptive run. Runs a short MCMC to let samplers adapt, then inspects samplerFunctions envs. — sampler_scales_after_run","title":"Extract sampler scales after a short adaptive run. Runs a short MCMC to let samplers adapt, then inspects samplerFunctions envs. — sampler_scales_after_run","text":"Extract sampler scales short adaptive run. Runs short MCMC let samplers adapt, inspects samplerFunctions envs.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_scales_after_run.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract sampler scales after a short adaptive run. Runs a short MCMC to let samplers adapt, then inspects samplerFunctions envs. — sampler_scales_after_run","text":"","code":"sampler_scales_after_run(build_fn, niter = 2000, nburnin = 500, thin = 1)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_scales_after_run.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract sampler scales after a short adaptive run. Runs a short MCMC to let samplers adapt, then inspects samplerFunctions envs. — sampler_scales_after_run","text":"build_fn function returning list(model, cmodel, monitors) niter total iterations (default 2000) nburnin burn-(default 500) thin thinning (kept API symmetry; used )","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_scales_after_run.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract sampler scales after a short adaptive run. Runs a short MCMC to let samplers adapt, then inspects samplerFunctions envs. — sampler_scales_after_run","text":"data.frame(name, type, target, scale)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_scales_from_run.html","id":null,"dir":"Reference","previous_headings":"","what":"Preferred: read scales from a fresh samplerConf list (pre-run). — sampler_scales_from_run","title":"Preferred: read scales from a fresh samplerConf list (pre-run). — sampler_scales_from_run","text":"Preferred: read scales fresh samplerConf list (pre-run).","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_scales_from_run.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preferred: read scales from a fresh samplerConf list (pre-run). — sampler_scales_from_run","text":"","code":"sampler_scales_from_run(run_result, build_fn)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Targets (node names) for each sampler in a MCMC configuration — sampler_targets","title":"Targets (node names) for each sampler in a MCMC configuration — sampler_targets","text":"Targets (node names) sampler MCMC configuration","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Targets (node names) for each sampler in a MCMC configuration — sampler_targets","text":"","code":"sampler_targets(conf)"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Targets (node names) for each sampler in a MCMC configuration — sampler_targets","text":"conf nimble MCMC configuration (configureMCMC)","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/sampler_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Targets (node names) for each sampler in a MCMC configuration — sampler_targets","text":"character vector (length = length(conf$getSamplers()))","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/test_strategy.html","id":null,"dir":"Reference","previous_headings":"","what":"Test and compare MCMC strategies on selected bottleneck nodes — test_strategy","title":"Test and compare MCMC strategies on selected bottleneck nodes — test_strategy","text":"Runs small, reproducible workflow () build model via build_fn, (ii) compute baseline default MCMC configuration, (iii) try alternative samplers strict, user-defined order one two “bottleneck” targets (singleton optional block union). Optionally attempts full-model HMC/NUTS first (nimbleHMC available model supports derivatives). Results diagnostic plots (R-hat bars trace/density) written out_dir.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/test_strategy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test and compare MCMC strategies on selected bottleneck nodes — test_strategy","text":"","code":"test_strategy(   build_fn,   monitors = NULL,   try_hmc = TRUE,   nchains = 3L,   pilot_niter = 20000,   pilot_burnin = 5000,   thin = 1L,   out_dir = \"outputs/diagnostics\",   nbot = 1L,   strict_scalar_seq = c(\"NUTS\", \"slice\", \"RW\"),   strict_block_seq = c(\"NUTS_block\", \"AF_slice\", \"RW_block\"),   force_singletons = NULL,   force_union_nodes = NULL,   force_union = NULL,   ask = TRUE,   ask_before_hmc = TRUE,   block_max = 20L,   slice_control = list(),   rw_control = list(),   rwblock_control = list(adaptScaleOnly = TRUE),   af_slice_control = list(),   slice_max_contractions = 5000L )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/test_strategy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test and compare MCMC strategies on selected bottleneck nodes — test_strategy","text":"build_fn Function (prebuilt list $model, $conf) returns fresh build object used samplers package. monitors Optional character vector monitors passed build. try_hmc Logical. TRUE, try full-model HMC/NUTS run first (ignored “surgical” singleton/block steps). nchains Integer number MCMC chains run. pilot_niter Integer total iterations used baseline tests. pilot_burnin Integer burn-iterations. thin Integer thinning interval. out_dir Directory outputs (plots, etc.) written. nbot Integer. Number bottleneck targets operate (1 2 typical; >= 2, block step union attempted). strict_scalar_seq Character vector scalar samplers try order. Supported values include \"NUTS\", \"slice\", \"RW\". strict_block_seq Character vector block samplers try order. Supported values include \"NUTS_block\", \"AF_slice\", \"RW_block\". force_singletons Optional character vector node names force singleton targets (first nbot valid nodes used). force_union_nodes Optional character vector node names define union block phase (must contain >= 2 valid nodes). force_union Deprecated alias force_union_nodes. ask Logical. TRUE, ask moving next step. ask_before_hmc Logical. TRUE, ask running full HMC. block_max Integer cap size block union. slice_control List controls passed \"slice\" samplers. rw_control List controls passed \"RW\" samplers. rwblock_control List controls passed \"RW_block\" samplers. af_slice_control List controls passed \"AF_slice\" samplers. slice_max_contractions Integer safety cap slice contractions.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/test_strategy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test and compare MCMC strategies on selected bottleneck nodes — test_strategy","text":"list elements : status Character status string. mode Character mode (e.g. \"HMC_full\", \"surgical_*\"). baseline Baseline run info (runtime, samples, diagnostics). targets Chosen target node names. steps List steps; contains nodes, sampler, results, directory.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/test_strategy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test and compare MCMC strategies on selected bottleneck nodes — test_strategy","text":"procedure: Build run baseline MCMC using run_baseline_config(). Optionally run full-model HMC/NUTS via configure_hmc_safely(). Select nbot bottleneck node(s) diagnostics (force_singletons), : apply strict_scalar_seq order first node; nbot >= 2, build union {node1, node2} (force_union_nodes) apply strict_block_seq. step, compile, run, compute diagnostics, save plots. ask = TRUE, interactive yes/prompts allow stop early.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/test_strategy.html","id":"side-effects","dir":"Reference","previous_headings":"","what":"Side effects","title":"Test and compare MCMC strategies on selected bottleneck nodes — test_strategy","text":"Creates subfolders PNG files (R-hat bars, traces/densities) out_dir. May load/unload compiled DLLs switching samplers.","code":""},{"path":[]},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/test_strategy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test and compare MCMC strategies on selected bottleneck nodes — test_strategy","text":"","code":"if (FALSE) { # \\dontrun{ res <- test_strategy(   build_fn = my_build_fn,   monitors = c(\"theta\",\"beta\"),   try_hmc  = TRUE,   nbot     = 2,   out_dir  = \"outputs/diagnostics\" ) } # } test_strategy #> function (build_fn, monitors = NULL, try_hmc = TRUE, nchains = 3L,  #>     pilot_niter = 20000, pilot_burnin = 5000, thin = 1L, out_dir = \"outputs/diagnostics\",  #>     nbot = 1L, strict_scalar_seq = c(\"NUTS\", \"slice\", \"RW\"),  #>     strict_block_seq = c(\"NUTS_block\", \"AF_slice\", \"RW_block\"),  #>     force_singletons = NULL, force_union_nodes = NULL, force_union = NULL,  #>     ask = TRUE, ask_before_hmc = TRUE, block_max = 20L, slice_control = list(),  #>     rw_control = list(), rwblock_control = list(adaptScaleOnly = TRUE),  #>     af_slice_control = list(), slice_max_contractions = 5000L)  #> { #>     `%||%` <- function(x, y) if (is.null(x))  #>         y #>     else x #>     stopifnot(nbot >= 1L) #>     if (is.list(build_fn) && !is.null(build_fn$model)) { #>         obj <- build_fn #>         build_fn <- function() obj #>     } #>     stopifnot(is.function(build_fn)) #>     if (!requireNamespace(\"nimble\", quietly = TRUE))  #>         stop(\"samOptiPro: 'nimble' is required.\") #>     if (!dir.exists(out_dir))  #>         dir.create(out_dir, recursive = TRUE, showWarnings = FALSE) #>     say <- function(...) { #>         msg <- try(sprintf(...), silent = TRUE) #>         if (!inherits(msg, \"try-error\"))  #>             cat(msg, \"\\n\") #>     } #>     is_ll <- function(x) grepl(\"^logLik(\\\\[.*\\\\])?$|log_?lik|logdens|lpdf\",  #>         x, perl = TRUE, ignore.case = TRUE) #>     .sanitize_iters <- local({ #>         warned <- FALSE #>         function(niter, nburnin) { #>             niter <- as.integer(niter) #>             nburnin <- as.integer(nburnin) #>             if (is.na(niter) || niter < 1L)  #>                 niter <- 1L #>             if (is.na(nburnin) || nburnin < 0L)  #>                 nburnin <- 0L #>             if (nburnin >= niter) { #>                 new_nburnin <- max(0L, niter - 1L) #>                 if (!warned) { #>                   message(sprintf(\"[info] Adjusting nburnin (%d) to %d because nburnin must be < niter (%d).\",  #>                     nburnin, new_nburnin, niter)) #>                   warned <<- TRUE #>                 } #>                 nburnin <- new_nburnin #>             } #>             list(niter = niter, nburnin = nburnin) #>         } #>     }) #>     .ask_yes_no_strict <- function(prompt) { #>         if (!isTRUE(ask) || !interactive())  #>             return(TRUE) #>         while (TRUE) { #>             cat(paste0(prompt, \" (yes/no): \")) #>             utils::flush.console() #>             ans <- try(readline(), silent = TRUE) #>             if (inherits(ans, \"try-error\"))  #>                 return(TRUE) #>             ans <- tolower(trimws(ans)) #>             if (ans %in% c(\"y\", \"yes\", \"o\", \"oui\"))  #>                 return(TRUE) #>             if (ans %in% c(\"n\", \"no\", \"non\"))  #>                 return(FALSE) #>             cat(\"Please answer 'yes' or 'no'.\\n\") #>         } #>     } #>     .barrier_before_block <- function(tag = \"scalar_to_block\") { #>         try(nimble::clearCompiled(), silent = TRUE) #>         gc() #>         new_bd <- file.path(tempdir(), paste0(\"samOptiPro_build_\",  #>             gsub(\"[^A-Za-z0-9_]+\", \"_\", tag), \"_\", as.integer(stats::runif(1,  #>                 1e+09, 9e+09)))) #>         dir.create(new_bd, recursive = TRUE, showWarnings = FALSE) #>         assign(\".sop_old_builddir\", nimble::nimbleOptions(\"buildDir\"),  #>             inherits = FALSE) #>         nimble::nimbleOptions(buildDir = new_bd) #>         if (.Platform$OS.type == \"windows\")  #>             Sys.sleep(0.3) #>         else Sys.sleep(0.05) #>         invisible(TRUE) #>     } #>     .restore_builddir <- function() { #>         old <- try(get(\".sop_old_builddir\", inherits = FALSE),  #>             silent = TRUE) #>         if (!inherits(old, \"try-error\") && !is.null(old))  #>             try(nimble::nimbleOptions(buildDir = old), silent = TRUE) #>         invisible(TRUE) #>     } #>     .ensure_unsampled <- function(conf) { #>         uns <- try(conf$getUnsampledNodes(), silent = TRUE) #>         if (!inherits(uns, \"try-error\") && length(uns)) { #>             uns <- uns[!is_ll(uns)] #>             for (u in uns) conf$addSampler(u, type = \"slice\") #>         } #>     } #>     .compile_and_run <- function(step_tag, build_obj, conf, niter,  #>         nburnin) { #>         it <- .sanitize_iters(niter, nburnin) #>         niter <- it$niter #>         nburnin <- it$nburnin #>         attempts <- 0L #>         last_err <- NULL #>         repeat { #>             attempts <- attempts + 1L #>             try(nimble::clearCompiled(), silent = TRUE) #>             gc() #>             res <- try({ #>                 .ensure_unsampled(conf) #>                 cmcmc <- .compile_mcmc_with_build(conf, build_obj,  #>                   reset = TRUE, show = FALSE) #>                 out <- .run_and_collect(cmcmc, niter = niter,  #>                   nburnin = nburnin, thin = thin, nchains = nchains) #>                 ml <- as_mcmc_list_sop(out$samples, out$samples2,  #>                   drop_loglik = FALSE, thin = thin) #>                 dg <- compute_diag_from_mcmc(ml, runtime_s = out$runtime_s) #>                 if (!is.null(cmcmc) && is.list(cmcmc) && \"unloadDLL\" %in%  #>                   names(cmcmc))  #>                   try(cmcmc$unloadDLL(), silent = TRUE) #>                 list(out = out, ml = ml, dg = dg) #>             }, silent = TRUE) #>             if (!inherits(res, \"try-error\"))  #>                 return(res) #>             last_err <- tryCatch(conditionMessage(attr(res, \"condition\")),  #>                 error = function(e) as.character(res)) #>             if (attempts == 1L)  #>                 message(sprintf(\"[info] First attempt failed at %s; retrying cleanly...\",  #>                   step_tag)) #>             else message(sprintf(\"[retry %d @ %s] %s\", attempts,  #>                 step_tag, last_err)) #>             build_obj <- .fresh_build(build_fn, monitors = monitors,  #>                 thin = thin) #>             conf <- build_obj$conf #>             if (attempts >= 3L)  #>                 stop(sprintf(\"Compilation failed after %d attempts at step '%s': %s\",  #>                   attempts, step_tag, last_err)) #>         } #>     } #>     .add_scalar <- function(conf, nodes, type, has_hmc) { #>         if (identical(type, \"NUTS\")) { #>             if (isTRUE(has_hmc)) { #>                 for (n in nodes) conf$addSampler(target = n,  #>                   type = \"NUTS\") #>             } #>             else { #>                 cat(\"[Info] nimbleHMC not available -> falling back to slice (scalar).\\n\") #>                 for (n in nodes) conf$addSampler(n, \"slice\",  #>                   slice_control) #>             } #>             return(invisible()) #>         } #>         if (identical(type, \"slice\")) { #>             for (n in nodes) conf$addSampler(n, \"slice\", slice_control) #>             return(invisible()) #>         } #>         if (identical(type, \"RW\")) { #>             for (n in nodes) conf$addSampler(n, \"RW\", rw_control) #>             return(invisible()) #>         } #>         for (n in nodes) conf$addSampler(n, \"slice\", slice_control) #>     } #>     .add_block <- function(conf, nodes, type, has_hmc, Sc = NULL) { #>         nodes <- unique(nodes) #>         if (length(nodes) < 2L) { #>             if (type == \"NUTS_block\")  #>                 .add_scalar(conf, nodes, \"NUTS\", has_hmc) #>             else if (type == \"AF_slice\")  #>                 for (n in nodes) conf$addSampler(n, \"AF_slice\",  #>                   af_slice_control) #>             else if (type == \"RW_block\")  #>                 for (n in nodes) conf$addSampler(n, \"RW\", rw_control) #>             else for (n in nodes) conf$addSampler(n, \"slice\",  #>                 slice_control) #>             return(invisible()) #>         } #>         if (identical(type, \"NUTS_block\")) { #>             if (isTRUE(has_hmc))  #>                 conf$addSampler(target = nodes, type = \"NUTS\") #>             else { #>                 cat(\"[Info] nimbleHMC not available -> falling back to AF_slice (block).\\n\") #>                 conf$addSampler(target = nodes, type = \"AF_slice\",  #>                   control = af_slice_control) #>             } #>             return(invisible()) #>         } #>         if (identical(type, \"AF_slice\")) { #>             ok <- TRUE #>             tryCatch({ #>                 conf$addSampler(target = nodes, type = \"AF_slice\",  #>                   control = af_slice_control) #>             }, error = function(e) ok <<- FALSE) #>             if (!ok)  #>                 for (n in nodes) conf$addSampler(n, \"slice\",  #>                   slice_control) #>             return(invisible()) #>         } #>         if (identical(type, \"RW_block\")) { #>             ctrl <- rwblock_control #>             if (!is.null(Sc))  #>                 ctrl$propCov <- Sc #>             conf$addSampler(nodes, \"RW_block\", ctrl) #>             return(invisible()) #>         } #>         for (n in nodes) conf$addSampler(n, \"slice\", slice_control) #>     } #>     .metrics_for <- function(dg, nodes) { #>         nodes <- nodes[!is.na(nodes) & nzchar(nodes)] #>         keep <- dg$target %in% nodes & !is_ll(dg$target) #>         list(AE = stats::median(dg$AE_ESS_per_it[keep], na.rm = TRUE),  #>             CE = stats::median(dg$ESS_per_sec[keep], na.rm = TRUE),  #>             Rhat = if (any(keep)) suppressWarnings(max(dg$Rhat[keep],  #>                 na.rm = TRUE)) else NA_real_) #>     } #>     .print_step <- function(title, label, nodes, sampler, runtime,  #>         met, base_dx, base_rt) { #>         nodes <- nodes[!is.na(nodes) & nzchar(nodes)] #>         say(\"--- %s ---\", title) #>         if (!is.null(label))  #>             say(\"Target(s): %s\", label) #>         say(\"Nodes: %s\", paste(nodes, collapse = \", \")) #>         say(\"Sampler: %s\", sampler) #>         say(\"Runtime_s: %.2f (baseline: %.2f)\", runtime %||%  #>             NA_real_, base_rt %||% NA_real_) #>         say(\"AE median (ESS/iter): %.3g (baseline: %.3g)\", met$AE %||%  #>             NA_real_, stats::median(base_dx$AE_ESS_per_it, na.rm = TRUE)) #>         say(\"CE median (ESS/s):    %.3g (baseline: %.3g)\", met$CE %||%  #>             NA_real_, stats::median(base_dx$ESS_per_sec, na.rm = TRUE)) #>         say(\"Rhat max:             %.3g (baseline max: %.3g)\",  #>             met$Rhat %||% NA_real_, suppressWarnings(max(base_dx$Rhat,  #>                 na.rm = TRUE))) #>     } #>     b0 <- .fresh_build(build_fn, monitors = monitors, thin = thin) #>     mdl <- b0$model #>     it <- .sanitize_iters(pilot_niter, pilot_burnin) #>     rb <- run_baseline_config(build_fn, it$niter, it$nburnin,  #>         thin, monitors, nchains) #>     base_ml <- as_mcmc_list_sop(rb$samples, rb$samples2, drop_loglik = FALSE,  #>         thin = thin) #>     base_dg <- compute_diag_from_mcmc(base_ml, runtime_s = rb$runtime_s) #>     base_dx <- base_dg[!is_ll(base_dg$target), , drop = FALSE] #>     say(\"Baseline runtime_s: %.2f s\", rb$runtime_s %||% NA_real_) #>     say(\"Baseline median AE(ESS/iter): %.3g\", stats::median(base_dx$AE_ESS_per_it,  #>         na.rm = TRUE)) #>     say(\"Baseline median CE(ESS/s):    %.3g\", stats::median(base_dx$ESS_per_sec,  #>         na.rm = TRUE)) #>     dg_struct <- try(diagnose_model_structure(mdl), silent = TRUE) #>     suppressWarnings(has_hmc <- requireNamespace(\"nimbleHMC\",  #>         quietly = TRUE)) #>     deriv_ok <- .sop_supports_derivs(mdl) #>     blockers <- character(0) #>     if (!inherits(dg_struct, \"try-error\") && !is.null(dg_struct)) { #>         if (isTRUE(dg_struct$has_truncation))  #>             blockers <- c(blockers, \"truncation\") #>         if (isTRUE(dg_struct$has_simplex))  #>             blockers <- c(blockers, \"simplex-constraint\") #>         if (isTRUE(dg_struct$has_non_diff_fun))  #>             blockers <- c(blockers, \"non-diff-function\") #>     } #>     nuts_ok_global <- isTRUE(try_hmc) && has_hmc && deriv_ok &&  #>         (length(blockers) == 0L) #>     if (isTRUE(nuts_ok_global)) { #>         if (.ask_yes_no_strict(sprintf(\"Baseline ready. Runtime=%.2fs; median AE=%.3g; median CE=%.3g\\nProceed with full-model HMC/NUTS?\",  #>             rb$runtime_s %||% NA_real_, median(base_dx$AE_ESS_per_it,  #>                 na.rm = TRUE), median(base_dx$ESS_per_sec, na.rm = TRUE)))) { #>             hmc_try <- configure_hmc_safely(build_fn = build_fn,  #>                 niter = it$niter, nburnin = it$nburnin, thin = thin,  #>                 monitors = monitors, nchains = nchains, out_dir = file.path(out_dir,  #>                   \"HMC_full\")) #>             if (isTRUE(hmc_try$ok)) { #>                 dg <- hmc_try$diag_tbl #>                 cat(sprintf(\"HMC runtime_s: %.3f\\n\", hmc_try$res$runtime_s %||%  #>                   NA_real_)) #>                 cat(sprintf(\"HMC median AE: %.3g ; CE: %.3g ; max Rhat: %.3g\\n\",  #>                   median(dg$AE_ESS_per_it, na.rm = TRUE), median(dg$ESS_per_sec,  #>                     na.rm = TRUE), if (all(is.na(dg$Rhat)))  #>                     NA_real_ #>                   else max(dg$Rhat, na.rm = TRUE))) #>                 return(list(mode = \"HMC_full\", baseline = list(runtime_s = rb$runtime_s,  #>                   samples = base_ml, diag_tbl = base_dg), hmc = hmc_try,  #>                   messages = \"Full HMC completed.\")) #>             } #>             else { #>                 cat(\"[Warn] Full-model HMC failed -> continuing with surgical singleton plan.\\n\") #>             } #>         } #>         else { #>             cat(\"User declined full-model HMC/NUTS. Switching to surgical singleton plan.\\n\") #>         } #>     } #>     stoch_nodes <- mdl$getNodeNames(stochOnly = TRUE, includeData = FALSE) #>     stoch_nodes <- stoch_nodes[!is_ll(stoch_nodes)] #>     if (is.null(force_union_nodes) && !is.null(force_union))  #>         force_union_nodes <- force_union #>     pick_nodes <- character(0) #>     if (!is.null(force_singletons) && length(force_singletons)) { #>         pn <- unique(force_singletons) #>         present <- intersect(pn, intersect(stoch_nodes, unique(colnames(as.matrix(base_ml[[1]]))))) #>         pick_nodes <- utils::head(present, nbot) #>     } #>     if (!length(pick_nodes)) { #>         node_like <- grepl(\"\\\\[\", base_dx$target) #>         if (any(node_like)) { #>             ord <- order(base_dx$ESS_per_sec[node_like], decreasing = FALSE) #>             cand <- base_dx$target[node_like][ord] #>             pick_nodes <- intersect(utils::head(cand, nbot),  #>                 stoch_nodes) #>         } #>     } #>     if (!length(pick_nodes)) { #>         if (!requireNamespace(\"coda\", quietly = TRUE))  #>             stop(\"samOptiPro: 'coda' package required for node-level ESS.\") #>         common_cols <- Reduce(intersect, lapply(base_ml, function(m) colnames(as.matrix(m)))) #>         node_cols <- intersect(common_cols, stoch_nodes) #>         if (length(node_cols)) { #>             ess_per_node <- sapply(node_cols, function(nm) { #>                 ess_ch <- sapply(base_ml, function(m) { #>                   X <- as.matrix(m) #>                   if (nm %in% colnames(X))  #>                     coda::effectiveSize(X[, nm]) #>                   else NA_real_ #>                 }) #>                 sum(ess_ch, na.rm = TRUE)/(rb$runtime_s %||%  #>                   1) #>             }) #>             ord <- order(ess_per_node, decreasing = FALSE) #>             pick_nodes <- utils::head(names(ess_per_node)[ord],  #>                 nbot) #>             pick_nodes <- pick_nodes[!is.na(pick_nodes)] #>         } #>     } #>     if (!length(pick_nodes)) { #>         present <- intersect(stoch_nodes, unique(colnames(as.matrix(base_ml[[1]])))) #>         pick_nodes <- utils::head(present, nbot) #>     } #>     if (!length(pick_nodes))  #>         stop(\"No stochastic singleton targets to operate on.\") #>     say(\"Selected singleton bottlenecks (nbot=%d): %s\", length(pick_nodes),  #>         paste(pick_nodes, collapse = \", \")) #>     steps <- list() #>     if (nbot == 1L) { #>         node1 <- pick_nodes[1] #>         for (samp in unique(as.character(strict_scalar_seq))) { #>             bS <- .fresh_build(build_fn, monitors = monitors,  #>                 thin = thin) #>             confS <- bS$conf #>             try(confS$removeSamplers(node1), silent = TRUE) #>             .add_scalar(confS, node1, samp, has_hmc) #>             itS <- .sanitize_iters(pilot_niter, pilot_burnin) #>             resS <- .compile_and_run(paste0(\"nbot1_\", gsub(\"[^A-Za-z0-9_]+\",  #>                 \"_\", node1), \"_\", samp), bS, confS, itS$niter,  #>                 itS$nburnin) #>             metS <- .metrics_for(resS$dg, node1) #>             .print_step(\"Scalar plan on singleton\", node1, node1,  #>                 samp, resS$out$runtime_s, metS, base_dx, rb$runtime_s) #>             pdir <- file.path(out_dir, sprintf(\"singleton_%s_%s\",  #>                 gsub(\"[^A-Za-z0-9_]\", \"_\", node1), samp)) #>             if (!dir.exists(pdir))  #>                 dir.create(pdir, recursive = TRUE, showWarnings = FALSE) #>             .plot_rhat_bar(resS$dg, nodes = node1, out_file = file.path(pdir,  #>                 \"rhat_bar.png\")) #>             .plot_traces(resS$ml, nodes = node1, out_file_prefix = file.path(pdir,  #>                 \"trace_\")) #>             steps <- c(steps, list(list(level = \"singleton-scalar\",  #>                 nodes = node1, sampler = samp, res = resS, dir = pdir))) #>             if (!.ask_yes_no_strict(sprintf(\"Proceed to the next sampler for '%s'?\",  #>                 node1)))  #>                 break #>         } #>         return(list(status = \"completed\", mode = \"surgical_nbot1_singleton\",  #>             baseline = rb, targets = pick_nodes, steps = steps)) #>     } #>     node1 <- pick_nodes[1] #>     for (samp in unique(as.character(strict_scalar_seq))) { #>         bS <- .fresh_build(build_fn, monitors = monitors, thin = thin) #>         confS <- bS$conf #>         try(confS$removeSamplers(node1), silent = TRUE) #>         .add_scalar(confS, node1, samp, has_hmc) #>         itS <- .sanitize_iters(pilot_niter, pilot_burnin) #>         resS <- .compile_and_run(paste0(\"nbot2_scalar_\", gsub(\"[^A-Za-z0-9_]+\",  #>             \"_\", node1), \"_\", samp), bS, confS, itS$niter, itS$nburnin) #>         metS <- .metrics_for(resS$dg, node1) #>         .print_step(\"Scalar plan on singleton\", node1, node1,  #>             samp, resS$out$runtime_s, metS, base_dx, rb$runtime_s) #>         pdir <- file.path(out_dir, sprintf(\"singleton_%s_%s\",  #>             gsub(\"[^A-Za-z0-9_]\", \"_\", node1), samp)) #>         if (!dir.exists(pdir))  #>             dir.create(pdir, recursive = TRUE, showWarnings = FALSE) #>         .plot_rhat_bar(resS$dg, nodes = node1, out_file = file.path(pdir,  #>             \"rhat_bar.png\")) #>         .plot_traces(resS$ml, nodes = node1, out_file_prefix = file.path(pdir,  #>             \"trace_\")) #>         steps <- c(steps, list(list(level = \"singleton-scalar\",  #>             nodes = node1, sampler = samp, res = resS, dir = pdir))) #>         if (!.ask_yes_no_strict(sprintf(\"Proceed to the next sampler for '%s'?\",  #>             node1)))  #>             break #>     } #>     node2 <- pick_nodes[2] %||% NA_character_ #>     union_nodes <- if (!is.null(force_union_nodes) && length(force_union_nodes) >=  #>         2L) { #>         present <- intersect(unique(force_union_nodes), intersect(mdl$getNodeNames(stochOnly = TRUE,  #>             includeData = FALSE), unique(colnames(as.matrix(base_ml[[1]]))))) #>         unique(present) #>     } #>     else unique(c(node1, node2)) #>     union_nodes <- union_nodes[!is.na(union_nodes) & nzchar(union_nodes)] #>     union_nodes <- unique(union_nodes) #>     if (length(union_nodes) > block_max)  #>         union_nodes <- utils::head(union_nodes, block_max) #>     if (length(union_nodes) < 2L) { #>         message(sprintf(\"[info] Skipping block phase: need at least 2 valid nodes, got %d (%s).\",  #>             length(union_nodes), paste(union_nodes, collapse = \", \"))) #>         return(list(status = \"completed\", mode = \"surgical_nbot2_singleton_no_block\",  #>             baseline = rb, targets = pick_nodes, steps = steps)) #>     } #>     .barrier_before_block(\"scalar_to_block_singletons\") #>     on.exit(.restore_builddir(), add = TRUE) #>     propCov <- NULL #>     M_full <- do.call(rbind, lapply(base_ml, function(m) { #>         X <- as.matrix(m) #>         keep <- intersect(colnames(X), union_nodes) #>         X[, keep, drop = FALSE] #>     })) #>     if (!is.null(M_full) && is.matrix(M_full) && ncol(M_full) >=  #>         2L) { #>         S <- try(stats::cov(M_full, use = \"pairwise.complete.obs\"),  #>             silent = TRUE) #>         if (!inherits(S, \"try-error\")) { #>             pc <- try(.sop_make_propCov_PD(S), silent = TRUE) #>             if (!inherits(pc, \"try-error\"))  #>                 propCov <- pc #>         } #>     } #>     for (samp in unique(as.character(strict_block_seq))) { #>         bB <- .fresh_build(build_fn, monitors = monitors, thin = thin) #>         confB <- bB$conf #>         for (n in union_nodes) try(confB$removeSamplers(n), silent = TRUE) #>         .add_block(confB, union_nodes, samp, has_hmc, Sc = propCov) #>         itB <- .sanitize_iters(pilot_niter, pilot_burnin) #>         resB <- .compile_and_run(paste0(\"nbot2_block_\", paste(gsub(\"[^A-Za-z0-9_]+\",  #>             \"_\", union_nodes), collapse = \"_\"), \"_\", samp), bB,  #>             confB, itB$niter, itB$nburnin) #>         metB <- .metrics_for(resB$dg, union_nodes) #>         .print_step(\"Block plan on union (singletons)\", paste(union_nodes,  #>             collapse = \" + \"), union_nodes, samp, resB$out$runtime_s,  #>             metB, base_dx, rb$runtime_s) #>         pdir <- file.path(out_dir, sprintf(\"block_union_singletons_%s\",  #>             paste(gsub(\"[^A-Za-z0-9_]+\", \"_\", union_nodes), collapse = \"_\"))) #>         if (!dir.exists(pdir))  #>             dir.create(pdir, recursive = TRUE, showWarnings = FALSE) #>         .plot_rhat_bar(resB$dg, nodes = union_nodes, out_file = file.path(pdir,  #>             \"rhat_bar.png\")) #>         .plot_traces(resB$ml, nodes = union_nodes, out_file_prefix = file.path(pdir,  #>             \"trace_\")) #>         steps <- c(steps, list(list(level = \"singletons-block\",  #>             nodes = union_nodes, sampler = samp, res = resB,  #>             dir = pdir))) #>         if (!.ask_yes_no_strict(\"Proceed to the next BLOCK sampler for the union?\"))  #>             break #>     } #>     return(list(status = \"completed\", mode = \"surgical_nbot2_singleton\",  #>         baseline = rb, targets = pick_nodes, steps = steps)) #> } #> <bytecode: 0x5585b03d92a0> #> <environment: namespace:samOptiPro>"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/test_strategy_family.html","id":null,"dir":"Reference","previous_headings":"","what":"Family-based sampler strategy: full HMC if allowed, else surgical on bottlenecks — test_strategy_family","title":"Family-based sampler strategy: full HMC if allowed, else surgical on bottlenecks — test_strategy_family","text":"model differentiable try_hmc = TRUE, runs full HMC/NUTS configuration (via configure_hmc_safely()), executes baseline, prints/plots diagnostics, returns. Otherwise switches surgical strategy: ranks families median efficiency, extracts stochastic bottleneck nodes, iteratively applies samplers 1 nodes (nbot) order: scalar: NUTS -> slice -> RW block (nbot >= 2): NUTS_block -> AF_slice -> RW_block assignment, short MCMC run, side--side comparison versus baseline printed (runtime, AE = ESS/iter, CE = ESS/s, Rhat), clean plots saved (Rhat bars + trace plots touched nodes), user prompted continue unless ask = FALSE.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/test_strategy_family.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Family-based sampler strategy: full HMC if allowed, else surgical on bottlenecks — test_strategy_family","text":"","code":"test_strategy_family(   build_fn,   monitors = NULL,   try_hmc = TRUE,   nchains = 3L,   pilot_niter = 4000L,   pilot_burnin = 1000L,   thin = 2L,   out_dir = \"outputs/diagnostics_family\",   nbot = 1L,   strict_scalar_seq = c(\"NUTS\", \"slice\", \"RW\"),   strict_block_seq = c(\"NUTS_block\", \"AF_slice\", \"RW_block\"),   force_families = NULL,   force_nodes = NULL,   force_union = NULL,   ask = TRUE,   ask_before_hmc = TRUE,   block_max = 20L,   slice_control = list(),   rw_control = list(),   rwblock_control = list(adaptScaleOnly = TRUE),   af_slice_control = list(),   slice_max_contractions = 5000L )"},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/test_strategy_family.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Family-based sampler strategy: full HMC if allowed, else surgical on bottlenecks — test_strategy_family","text":"build_fn Function; returns list(model, cmodel?, monitors?) used runners. monitors Character NULL; root names monitor (NULL = auto). try_hmc Logical; TRUE structure allows, run full HMC path. nchains Integer; number chains. pilot_niter Integer; iterations pilot runs. pilot_burnin Integer; burn-pilot runs. thin Integer; thinning factor. out_dir Character; output directory diagnostics/plots. nbot Integer (\\(\\ge\\) 1); number bottleneck nodes act simultaneously. strict_scalar_seq Character; sampler order scalar mode. strict_block_seq Character; sampler order block mode (nbot >= 2). force_families Character NULL; families force. force_nodes List NULL; per-family forced node vectors. force_union Character NULL; families union block stage. ask Logical; interactive confirmation step. ask_before_hmc Logical; ask attempting full-model HMC. block_max Integer; maximum block size. slice_control, rw_control, rwblock_control, af_slice_control Lists; sampler controls. slice_max_contractions Integer; informational safety AF_slice.","code":""},{"path":"https://RomualdEcoStats.github.io/samOptiPro-core/reference/test_strategy_family.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Family-based sampler strategy: full HMC if allowed, else surgical on bottlenecks — test_strategy_family","text":"list describing baseline, steps, configurations, diagnostics, plot paths. test_strategy_family","code":""}]
