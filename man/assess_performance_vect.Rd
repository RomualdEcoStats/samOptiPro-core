% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/assess.R
\name{assess_performance_vect}
\alias{assess_performance_vect}
\title{Assess MCMC performance metrics (ESS, R-hat, AE, CE) using vectorised backends}
\usage{
assess_performance_vect(
  samples,
  runtime_s,
  rhat_thresh = 1.01,
  ess_type = c("bulk", "tail"),
  drop_const = TRUE,
  tol_var = 0,
  drop_na = TRUE
)
}
\arguments{
\item{samples}{A list of MCMC samples or any object that can be converted
by \code{as_mcmc_list()}.}

\item{runtime_s}{Numeric scalar. Total runtime of the MCMC run (seconds).}

\item{rhat_thresh}{Numeric scalar. Threshold used to flag R-hat values
indicating lack of convergence. Default is 1.01.}

\item{ess_type}{Character string specifying which ESS definition to use.
Either \code{"bulk"} (default) or \code{"tail"}.}

\item{drop_const}{Logical. Whether parameters with zero (or near-zero)
variance across all chains should be excluded prior to computing
diagnostics. Default is \code{TRUE}.}

\item{tol_var}{Numeric scalar. Variance tolerance used to identify
constant or near-constant parameters. Default is 0.}
}
\value{
A named list containing:
\describe{
\item{\code{summary}}{A one-row tibble summarizing global diagnostics.}
\item{\code{per_param}}{A tibble containing ESS, Rhat, AE, and CE
for each parameter.}
\item{\code{dropped_zero_var}}{A character vector listing parameters
excluded due to zero or near-zero variance.}
}
}
\description{
Compute per-parameter and global performance diagnostics from an MCMC sample
set using vectorised implementations of convergence metrics.
Metrics include Effective Sample Size (ESS), Gelman–Rubin R-hat,
Algorithmic Efficiency (AE = ESS / total draws), and Computational
Efficiency (CE = ESS / runtime in seconds).
}
\details{
The function first coerces the input to an \code{mcmc.list} object and then
converts it to a \pkg{posterior} draws object to compute diagnostics in a
vectorised manner.

The following metrics are computed:
\itemize{
\item \strong{ESS}: Effective Sample Size per parameter, computed using
\code{posterior::ess_bulk()} or \code{posterior::ess_tail()}.
\item \strong{Rhat}: Gelman–Rubin convergence diagnostic computed via
\code{posterior::rhat()} (requires at least two chains).
\item \strong{AE}: Algorithmic efficiency, defined as ESS divided by
the total number of retained post-burnin draws.
\item \strong{CE}: Computational efficiency, defined as ESS divided by
the total runtime in seconds.
}

Optionally, parameters with zero (or near-zero) variance across all chains
can be excluded prior to diagnostic computation to avoid numerical failures
in ESS estimation.
}
\examples{
\dontrun{
res <- run_baseline_config(build_M, niter = 2000, nburnin = 500, thin = 2)
perf <- assess_performance_vect(
  res$samples,
  runtime_s = res$runtime_s,
  ess_type = "bulk"
)
perf$summary
}

}
\seealso{
coda::effectiveSize,
coda::gelman.diag,
posterior::ess_bulk,
posterior::ess_tail,
posterior::rhat
}
