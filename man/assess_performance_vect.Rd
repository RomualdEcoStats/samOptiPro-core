% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/assess.R
\name{assess_performance_vect}
\alias{assess_performance_vect}
\title{Assess MCMC performance metrics (ESS, R-hat, AE, CE) using vectorised backends}
\usage{
assess_performance_vect(
  samples,
  runtime_s,
  rhat_thresh = 1.01,
  ess_type = c("bulk", "tail"),
  drop_const = TRUE,
  tol_var = 0,
  drop_na = TRUE
)
}
\arguments{
\item{samples}{MCMC samples: a \code{coda::mcmc.list}, \code{coda::mcmc}, a
matrix/data.frame, or any object accepted by \code{as_mcmc_list()}.}

\item{runtime_s}{Numeric scalar; total runtime (seconds) corresponding to
the MCMC run(s) that produced \code{samples}. This is used to compute CE.}

\item{rhat_thresh}{Numeric scalar; threshold used to flag lack of convergence
based on \eqn{\hat{R}}. Default is 1.01.}

\item{ess_type}{Character; ESS definition to use. One of \code{"bulk"} or
\code{"tail"} (default = \code{"bulk"}).}

\item{drop_const}{Logical; if \code{TRUE}, drop parameters with zero or
near-zero variance across all chains before computing diagnostics.}

\item{tol_var}{Numeric scalar; variance tolerance used to identify near-constant
parameters (default = 0).}

\item{drop_na}{Logical; if \code{TRUE}, drop rows with missing diagnostics
before computing summaries (default = \code{TRUE}).}
}
\value{
A named list with:
\describe{
\item{\code{summary}}{A one-row tibble/data.frame summarising global
diagnostics (e.g. median ESS, max \eqn{\hat{R}}, AE/CE summaries).}
\item{\code{per_param}}{A tibble/data.frame with per-parameter ESS,
\eqn{\hat{R}}, AE, and CE.}
\item{\code{dropped_zero_var}}{Character vector of parameters removed due
to zero or near-zero variance (when \code{drop_const=TRUE}).}
}
}
\description{
Compute per-parameter and global performance diagnostics from MCMC output
using vectorised implementations of convergence and efficiency metrics.
The main outputs are Effective Sample Size (ESS), Gelman--Rubin \eqn{\hat{R}},
Algorithmic Efficiency (AE), and Computational Efficiency (CE).
}
\details{
The function first coerces \code{samples} to a \code{coda::mcmc.list}
(via \code{as_mcmc_list()}), then converts it to a \pkg{posterior} draws
object to compute diagnostics in a vectorised manner.

Computed metrics:
\itemize{
\item \strong{ESS}: Effective Sample Size per parameter, computed using
\code{posterior::ess_bulk()} (bulk ESS) or \code{posterior::ess_tail()}
(tail ESS), controlled by \code{ess_type}.
\item \strong{Rhat}: Gelman--Rubin convergence diagnostic computed with
\code{posterior::rhat()} (requires at least two chains).
\item \strong{AE}: Algorithmic efficiency, defined as
\code{ESS / n_draws}, where \code{n_draws} is the number of retained
post-burn-in draws per chain (after thinning).
\item \strong{CE}: Computational efficiency, defined as \code{ESS / runtime_s}.
}

To improve robustness in high-dimensional models, parameters with zero or
near-zero variance across chains can be removed prior to computing ESS and
\eqn{\hat{R}} (\code{drop_const = TRUE}). Optionally, rows with missing
diagnostics can be removed from summaries (\code{drop_na = TRUE}).
}
\examples{
\dontrun{
res <- run_baseline_config(build_M, niter = 2000, nburnin = 500, thin = 2)
perf <- assess_performance_vect(
  res$samples,
  runtime_s = res$runtime_s,
  ess_type  = "bulk"
)
perf$summary
}

}
\seealso{
\code{\link[coda]{effectiveSize}},
\code{\link[coda]{gelman.diag}},
\code{\link[posterior]{ess_bulk}},
\code{\link[posterior]{ess_tail}},
\code{\link[posterior]{rhat}}
}
