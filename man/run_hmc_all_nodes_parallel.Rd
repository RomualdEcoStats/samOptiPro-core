% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runners.R
\name{run_hmc_all_nodes_parallel}
\alias{run_hmc_all_nodes_parallel}
\title{Run HMC/NUTS on all eligible nodes (with slice fallback), optionally in parallel}
\usage{
run_hmc_all_nodes_parallel(
  build_fn,
  niter,
  nburnin = floor(0.25 * niter),
  thin = 1L,
  monitors = NULL,
  nchains = 1L,
  opts = samOptiPro_options()
)
}
\arguments{
\item{build_fn}{Builder function that creates a fresh NIMBLE model and returns a list
with at least \code{model}, \code{cmodel} and \code{conf}. For parallel execution,
the builder should accept \code{chain_id} and build/compile chain-specific objects.}

\item{niter}{Total number of MCMC iterations.}

\item{nburnin}{Number of burn-in iterations discarded.}

\item{thin}{Thinning interval (keep 1 draw every \code{thin} iterations).}

\item{monitors}{Optional character vector of monitor roots. If \code{NULL}, monitors
may be inferred by \code{.fresh_build()} or taken from the builder output.}

\item{nchains}{Integer; number of chains. If \code{nchains > 1} and the builder
supports \code{chain_id}, chains are run in parallel (PSOCK).}

\item{opts}{List of options as returned by \code{samOptiPro_options()} (e.g. seed,
export strategy handled by \code{.fresh_build()}).}
}
\value{
A list with components:
\describe{
\item{samples}{Posterior draws (typically a \code{coda::mcmc.list} in parallel mode).}
\item{samples2}{Optional secondary draws (as produced by \code{.run_and_collect()}).}
\item{runtime_s}{Runtime (seconds) of the sampling phase; slowest chain in parallel mode.}
\item{conf}{MCMC configuration (\code{nimbleMCMCconf}) in sequential mode; \code{NULL} in parallel.}
\item{hmc_applied}{Logical; \code{TRUE} if HMC/NUTS configuration succeeded (all chains in parallel).}
\item{conf_by_chain}{List of per-chain MCMC configurations (parallel mode); also attached as an attribute.}
}
}
\description{
Configures gradient-based MCMC using \pkg{nimbleHMC} (HMC/NUTS) for all nodes
that can be handled by HMC. Any remaining unsampled nodes are automatically
assigned a slice sampler as a robust fallback. If \code{nchains > 1} and
\code{build_fn} supports a \code{chain_id} argument, chains are run in true
parallel (PSOCK). Otherwise, execution falls back to a safe sequential mode.
}
\details{
Runtime is measured for the sampling phase only (around \code{runMCMC()}), not for
model/MCMC compilation. In parallel mode, \code{runtime_s} is the maximum runtime
across chains (slowest chain). Because each chain has its own MCMC configuration
(after HMC + slice fallback), \code{conf} is returned in sequential mode only.
}
\examples{
\dontrun{
res <- run_hmc_all_nodes(
  build_fn  = build_M,
  niter     = 2000,
  nburnin   = 500,
  thin      = 2,
  monitors  = c("N", "logit_theta"),
  nchains   = 4
)
}

}
