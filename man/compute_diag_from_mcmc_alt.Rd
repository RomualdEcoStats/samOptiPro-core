% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/diagnostics.R
\name{compute_diag_from_mcmc_alt}
\alias{compute_diag_from_mcmc_alt}
\title{Scalable diagnostics for large MCMC objects (classic layout, block-wise)}
\usage{
compute_diag_from_mcmc_alt(samples, runtime_s)
}
\arguments{
\item{samples}{An \code{mcmc.list}, \code{mcmc}, or numeric matrix of samples.
Chains must share at least one common parameter name.}

\item{runtime_s}{Numeric scalar; total runtime in seconds associated with the
MCMC run(s), assumed to be the wall-clock time for the full set of chains.}
}
\value{
A \code{data.frame} with one row per parameter and the classic columns
expected by \code{\link{compute_diag_from_mcmc}}:
\describe{
\item{target}{Parameter name (column name in the MCMC object).}
\item{ESS}{Effective sample size used for efficiency summaries (worst-chain ESS).}
\item{AE_ESS_per_it}{Algorithmic efficiency: \code{ESS / n_iter}.}
\item{ESS_per_sec}{Computational efficiency: \code{ESS / runtime_s}.}
\item{time_s_per_ESS}{Seconds per effective sample: \code{runtime_s / ESS}.}
\item{Family}{Top-level node family (substring of \code{target} before the first \code{"["}).}
}
}
\description{
Compute convergence and efficiency diagnostics from high-dimensional MCMC
outputs (\code{mcmc.list}, \code{mcmc}, or numeric matrices) using a
block-wise, vectorized backend while preserving the \emph{classic} return layout
of \code{\link{compute_diag_from_mcmc}}.
}
\details{
This function targets models with tens of thousands of monitored parameters
(e.g., large hierarchical stock-assessment or life-cycle models such as
WGNAS, GEREM, and Scorff LCM), for which naive per-parameter loops can become
slow or memory-bound.

Chains are first harmonized by truncating to the shortest common length and
aligning to a common set of parameter names. Diagnostics are then computed
in column blocks to control memory usage. The \code{ESS} column in the output
corresponds to a conservative \emph{worst-chain} ESS (minimum across chains), and
the classic efficiency metrics are derived as:
\itemize{
\item \code{AE_ESS_per_it = ESS / n_iter},
\item \code{ESS_per_sec   = ESS / runtime_s},
\item \code{time_s_per_ESS = runtime_s / ESS}.
}

The goal is backward compatibility with downstream consumers of
\code{compute_diag_from_mcmc} (plots, summaries, bottleneck detectors),
while scaling to very large parameter vectors via a vectorized backend.
}
\seealso{
\code{\link{compute_diag_from_mcmc}},
\code{\link[coda]{effectiveSize}},
Vehtari et al. (2021), \emph{Bayesian Analysis} 16(2):667--718.
}
