% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/diagnostics.R
\name{configure_hmc_safely_parallel}
\alias{configure_hmc_safely_parallel}
\title{Configure and run HMC/NUTS safely in true parallel (one chain per worker)}
\usage{
configure_hmc_safely_parallel(
  build_fn,
  niter,
  nburnin,
  thin,
  nchains,
  monitors,
  inits = NULL,
  enable_WAIC = FALSE,
  show_compiler_output = FALSE,
  log_dir = "log",
  seed = 1L
)
}
\arguments{
\item{build_fn}{Function; model builder used to construct the NIMBLE model
and base MCMC configuration (e.g. \code{build_M}). If
\code{.fresh_build()} is available on workers, it is called as
\code{.fresh_build(build_fn, monitors, thin)}; otherwise,
\code{build_fn()} must return a list with at least \code{model} and
\code{conf}. If \code{build_fn} accepts a \code{chain_id} argument, it is
passed automatically.}

\item{niter}{Integer; total number of MCMC iterations per chain.}

\item{nburnin}{Integer (>= 0); number of burn-in iterations.}

\item{thin}{Integer (>= 1); thinning interval.}

\item{nchains}{Integer (>= 1); number of chains (one PSOCK worker per chain).}

\item{monitors}{Character vector or \code{NULL}; nodes to monitor, passed to
model building and/or HMC configuration.}

\item{inits}{\code{NULL} or a list of per-chain initial values. If provided,
its length must match \code{nchains}; each element is passed to the
corresponding worker.}

\item{enable_WAIC}{Logical; whether to enable WAIC computation (if supported).}

\item{show_compiler_output}{Logical; forwarded to
\code{nimbleOptions(showCompilerOutput = ...)} on each worker.}

\item{log_dir}{Character; directory for worker-level logs (if enabled).}

\item{seed}{Integer; base RNG seed. Chain \code{i} uses \code{seed + i - 1}.}
}
\value{
A list with components:
\itemize{
\item \code{conf}: final MCMC configuration (from chain 1),
\item \code{cmcmc}: compiled MCMC object (from chain 1),
\item \code{samples}: combined \code{coda::mcmc.list} (one chain per worker),
\item \code{runtime_s}: wall-clock time in seconds (maximum over chains),
\item \code{build}: build object returned by \code{build_fn} or
\code{.fresh_build()} (from chain 1).
}
}
\description{
Parallel counterpart of \code{configure_hmc_safely_bis}, implementing \emph{true}
parallelism by running \strong{one MCMC chain per PSOCK worker}
(\code{parallel::makeCluster}). Each chain is executed in an isolated R
session, and results are aggregated on the master into a single
\code{coda::mcmc.list}.
}
\details{
Relative to the sequential implementation, this function:
\itemize{
\item launches a dedicated PSOCK worker for each chain, ensuring full
memory and RNG isolation (no forking),
\item initializes each worker by attaching \pkg{nimble} (and
\pkg{nimbleHMC} when available) and defining internal helpers that
compiled or lifted NIMBLE code may call unqualified,
\item runs \code{nimble::runMCMC(..., nchains = 1L)} independently on each
worker and combines chains on the master,
\item reports \code{runtime_s} as the \strong{maximum elapsed time across
chains}, corresponding to the effective wall-clock time of the
parallel execution,
\item returns compiled objects (\code{conf}, \code{cmcmc}, \code{build})
from the first chain only, avoiding the transfer of large compiled
objects from all workers.
}

In contrast to mixed or fallback strategies, this function performs a
\emph{strict} HMC/NUTS configuration: no per-node fallback (e.g.
\code{addSampler(type = "slice")}) is attempted. Any failure during HMC
configuration or execution results in an error.
}
