% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/diagnostics.R
\name{run_custom_mcmc_parallel}
\alias{run_custom_mcmc_parallel}
\title{Run a fully customizable NIMBLE MCMC configuration in parallel (baseline / onlySlice / overrides)}
\usage{
run_custom_mcmc_parallel(
  build_fn,
  niter,
  nburnin = floor(0.25 * niter),
  thin = 1L,
  monitors = NULL,
  nchains = 1L,
  seed = 1L,
  n_cores = nchains,
  extra_export = character(0),
  parallel_backend = c("PSOCK", "FORK", "AUTO"),
  worker_log = TRUE,
  base_policy = c("baseline", "onlySlice", "none"),
  useConjugacy = FALSE,
  override_nodes = NULL,
  override_families = NULL,
  family_roots = NULL,
  ensure_unsampled = TRUE,
  allow_hmc = TRUE,
  mcmc_project = c("cmodel", "model"),
  buildDerivs = NULL
)
}
\arguments{
\item{build_fn}{Function that builds one chain. Preferably supports
\code{build_fn(chain_id = 1L, export_global = FALSE)} and returns at least \code{model},
and optionally \code{cmodel} and \code{conf}.}

\item{niter}{Integer; total number of MCMC iterations.}

\item{nburnin}{Integer; burn-in iterations to discard.}

\item{thin}{Integer; thinning interval (keep 1 draw every \code{thin} iterations).}

\item{monitors}{Character vector of monitor roots; passed to configuration (or added when possible).}

\item{nchains}{Integer; number of independent chains.}

\item{seed}{Integer; base RNG seed; chain \code{i} uses \code{seed + i - 1}.}

\item{n_cores}{Integer; number of workers (default = \code{nchains}).}

\item{extra_export}{Character vector of additional global object names to export to PSOCK workers.}

\item{parallel_backend}{One of \code{"PSOCK"}, \code{"FORK"}, or \code{"AUTO"}.}

\item{worker_log}{Logical; if TRUE (PSOCK), writes worker output to a temporary log and appends tail on errors.}

\item{base_policy}{One of \code{"baseline"}, \code{"onlySlice"}, \code{"none"}.}

\item{useConjugacy}{Logical; forwarded to \code{nimble::configureMCMC} when building a fresh config.}

\item{override_nodes}{Optional list of override rules for explicit targets. Each element is a list with fields:
\code{target} (character vector of node names), \code{type} (sampler type), optional \code{control} (list).}

\item{override_families}{Optional list of override rules for families. Each element is a list with fields:
\code{family} (root name), \code{type}, optional \code{control}.}

\item{family_roots}{Optional named list mapping family root -> explicit node vector, used to override default family expansion.}

\item{ensure_unsampled}{Logical; if TRUE, add \code{slice} to any remaining unsampled nodes after applying overrides.}

\item{allow_hmc}{Logical; if TRUE, enables \pkg{nimbleHMC} integration when overrides request \code{NUTS/HMC}.}

\item{mcmc_project}{One of \code{"cmodel"} or \code{"model"}; controls the \code{project=} argument used when
compiling the MCMC. Use \code{"model"} to match some legacy patterns (e.g. GEREM historical scripts).}

\item{buildDerivs}{Optional (reserved for future compatibility); currently ignored because the model is built in \code{build_fn}.}
}
\value{
A list with \code{samples}, \code{runtime_s}, \code{conf}, and \code{conf_by_chain}.
}
\description{
General-purpose parallel backend to run multiple independent NIMBLE MCMC chains while
programmatically controlling the sampler configuration:
a global "base policy" (e.g. baseline samplers or \code{onlySlice=TRUE}) plus optional
targeted overrides on specific nodes or node families (e.g. force \code{NUTS} on \code{beta},
set \code{RW_block} on \code{logq[1:5]}, etc.). This is designed for robust, model-agnostic
experimentation in diagnostic-driven workflows.
}
\details{
Key features:
\itemize{
\item \strong{Base policy}:
\describe{
\item{\code{"baseline"}}{Use \code{conf} returned by \code{build_fn} (e.g. default RW/dirichlet/posterior_predictive).}
\item{\code{"onlySlice"}}{Rebuild MCMC configuration with \code{nimble::configureMCMC(..., onlySlice=TRUE)}.}
\item{\code{"none"}}{Start from a configuration with all samplers removed, then add only what is requested via overrides (advanced).}
}
\item \strong{Targeted overrides}:
\describe{
\item{\code{override_nodes}}{List of rules applied to explicit node targets.}
\item{\code{override_families}}{List of rules applied to all stochastic nodes sharing the same root (family).}
}
Rules are lists with at least \code{type} and \code{target} (for nodes) or \code{family} (for families),
and optional \code{control}. Supported sampler \code{type} values include \code{"slice"}, \code{"RW"},
\code{"RW_block"}, \code{"AF_slice"}, \code{"NUTS"}, \code{"NUTS_block"} (the latter require \pkg{nimbleHMC}).
\item \strong{Unsampled-node safety}: if \code{ensure_unsampled=TRUE}, any remaining unsampled stochastic nodes
receive a \code{slice} sampler to avoid invalid configurations.
\item \strong{Parallel backends}: \code{"PSOCK"} (portable) or \code{"FORK"} (Unix); \code{"AUTO"} selects
\code{"FORK"} on Unix and \code{"PSOCK"} otherwise.
\item \strong{GEREM-style stability option}: \code{mcmc_project} controls whether the compiled MCMC is built
against the compiled model (\code{"cmodel"}) or the uncompiled \code{nimbleModel} (\code{"model"}). Some
legacy scripts and certain models may be more stable with \code{mcmc_project="model"}.
}

Requirements / contract:
\itemize{
\item \code{build_fn} must return a list containing at least \code{$model} (a \code{nimbleModel} object).
\item For \code{base_policy="baseline"}, \code{build_fn} must also provide \code{$conf} (a \code{MCMCconf}).
\item If \code{$cmodel} is not returned, it is compiled internally (per chain).
\item For true parallel execution, \code{build_fn} should accept \code{chain_id} (and optionally \code{export_global})
so each worker can build an independent chain with distinct initial values.
}

Returned object:
\itemize{
\item \code{samples}: an \code{mcmc.list} when possible (otherwise a list of per-chain samples)
\item \code{runtime_s}: the maximum wall time across chains for the \code{runMCMC} phase
\item \code{conf}: \code{NULL} in parallel mode (unambiguous); a single \code{conf} object in sequential mode
\item \code{conf_by_chain}: list of per-chain \code{MCMCconf} objects (also stored as an attribute)
}
}
