<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Test and compare MCMC strategies on selected bottleneck nodes — test_strategy • samOptiPro</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Test and compare MCMC strategies on selected bottleneck nodes — test_strategy"><meta name="description" content="Runs a small, reproducible workflow to (i) build a model via build_fn,
(ii) compute a baseline with the default MCMC configuration, then (iii)
try alternative samplers in a strict, user-defined order on one or two
“bottleneck” targets (singleton and then optional block on the union).
Optionally attempts full-model HMC/NUTS first (if nimbleHMC is available
and the model supports derivatives). Results and diagnostic plots
(R-hat bars and trace/density) are written under out_dir."><meta property="og:description" content="Runs a small, reproducible workflow to (i) build a model via build_fn,
(ii) compute a baseline with the default MCMC configuration, then (iii)
try alternative samplers in a strict, user-defined order on one or two
“bottleneck” targets (singleton and then optional block on the union).
Optionally attempts full-model HMC/NUTS first (if nimbleHMC is available
and the model supports derivatives). Results and diagnostic plots
(R-hat bars and trace/density) are written under out_dir."></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">samOptiPro</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/RomualdEcoStats/samOptiPro-core" aria-label="Source on GitHub"><span class="fa fab fa-github"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Test and compare MCMC strategies on selected bottleneck nodes</h1>
      <small class="dont-index">Source: <a href="https://github.com/RomualdEcoStats/samOptiPro-core/blob/main/R/diagnostics.R" class="external-link"><code>R/diagnostics.R</code></a></small>
      <div class="d-none name"><code>test_strategy.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Runs a small, reproducible workflow to (i) build a model via <code>build_fn</code>,
(ii) compute a baseline with the default MCMC configuration, then (iii)
try alternative samplers in a <em>strict</em>, user-defined order on one or two
“bottleneck” targets (singleton and then optional block on the union).
Optionally attempts full-model HMC/NUTS first (if <code>nimbleHMC</code> is available
and the model supports derivatives). Results and diagnostic plots
(R-hat bars and trace/density) are written under <code>out_dir</code>.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">test_strategy</span><span class="op">(</span></span>
<span>  <span class="va">build_fn</span>,</span>
<span>  monitors <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  try_hmc <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  nchains <span class="op">=</span> <span class="fl">3L</span>,</span>
<span>  pilot_niter <span class="op">=</span> <span class="fl">20000</span>,</span>
<span>  pilot_burnin <span class="op">=</span> <span class="fl">5000</span>,</span>
<span>  thin <span class="op">=</span> <span class="fl">1L</span>,</span>
<span>  out_dir <span class="op">=</span> <span class="st">"outputs/diagnostics"</span>,</span>
<span>  nbot <span class="op">=</span> <span class="fl">1L</span>,</span>
<span>  strict_scalar_seq <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"NUTS"</span>, <span class="st">"slice"</span>, <span class="st">"RW"</span><span class="op">)</span>,</span>
<span>  strict_block_seq <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"NUTS_block"</span>, <span class="st">"AF_slice"</span>, <span class="st">"RW_block"</span><span class="op">)</span>,</span>
<span>  force_singletons <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  force_union_nodes <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  force_union <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  ask <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  ask_before_hmc <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  block_max <span class="op">=</span> <span class="fl">20L</span>,</span>
<span>  slice_control <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  rw_control <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  rwblock_control <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>adaptScaleOnly <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  af_slice_control <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  slice_max_contractions <span class="op">=</span> <span class="fl">5000L</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-build-fn">build_fn<a class="anchor" aria-label="anchor" href="#arg-build-fn"></a></dt>
<dd><p>Function (or prebuilt list with <code>$model</code>, <code>$conf</code>)
that returns a fresh build object used by samplers in this package.</p></dd>


<dt id="arg-monitors">monitors<a class="anchor" aria-label="anchor" href="#arg-monitors"></a></dt>
<dd><p>Optional character vector of monitors passed to the build.</p></dd>


<dt id="arg-try-hmc">try_hmc<a class="anchor" aria-label="anchor" href="#arg-try-hmc"></a></dt>
<dd><p>Logical. If <code>TRUE</code>, try a full-model HMC/NUTS run first
(ignored by the “surgical” singleton/block steps).</p></dd>


<dt id="arg-nchains">nchains<a class="anchor" aria-label="anchor" href="#arg-nchains"></a></dt>
<dd><p>Integer number of MCMC chains for each run.</p></dd>


<dt id="arg-pilot-niter">pilot_niter<a class="anchor" aria-label="anchor" href="#arg-pilot-niter"></a></dt>
<dd><p>Integer total iterations used in baseline and tests.</p></dd>


<dt id="arg-pilot-burnin">pilot_burnin<a class="anchor" aria-label="anchor" href="#arg-pilot-burnin"></a></dt>
<dd><p>Integer burn-in iterations.</p></dd>


<dt id="arg-thin">thin<a class="anchor" aria-label="anchor" href="#arg-thin"></a></dt>
<dd><p>Integer thinning interval.</p></dd>


<dt id="arg-out-dir">out_dir<a class="anchor" aria-label="anchor" href="#arg-out-dir"></a></dt>
<dd><p>Directory where outputs (plots, etc.) will be written.</p></dd>


<dt id="arg-nbot">nbot<a class="anchor" aria-label="anchor" href="#arg-nbot"></a></dt>
<dd><p>Integer. Number of bottleneck targets to operate on (1 or 2
typical; if <code>&gt;= 2</code>, a block step on the union is attempted).</p></dd>


<dt id="arg-strict-scalar-seq">strict_scalar_seq<a class="anchor" aria-label="anchor" href="#arg-strict-scalar-seq"></a></dt>
<dd><p>Character vector of scalar samplers to try in order.
Supported values include <code>"NUTS"</code>, <code>"slice"</code>, <code>"RW"</code>.</p></dd>


<dt id="arg-strict-block-seq">strict_block_seq<a class="anchor" aria-label="anchor" href="#arg-strict-block-seq"></a></dt>
<dd><p>Character vector of block samplers to try in order.
Supported values include <code>"NUTS_block"</code>, <code>"AF_slice"</code>,
<code>"RW_block"</code>.</p></dd>


<dt id="arg-force-singletons">force_singletons<a class="anchor" aria-label="anchor" href="#arg-force-singletons"></a></dt>
<dd><p>Optional character vector of node names to force as
singleton targets (first <code>nbot</code> valid nodes are used).</p></dd>


<dt id="arg-force-union-nodes">force_union_nodes<a class="anchor" aria-label="anchor" href="#arg-force-union-nodes"></a></dt>
<dd><p>Optional character vector of node names to define
the union for the block phase (must contain <code>&gt;= 2</code> valid nodes).</p></dd>


<dt id="arg-force-union">force_union<a class="anchor" aria-label="anchor" href="#arg-force-union"></a></dt>
<dd><p>Deprecated alias of <code>force_union_nodes</code>.</p></dd>


<dt id="arg-ask">ask<a class="anchor" aria-label="anchor" href="#arg-ask"></a></dt>
<dd><p>Logical. If <code>TRUE</code>, ask before moving to the next step.</p></dd>


<dt id="arg-ask-before-hmc">ask_before_hmc<a class="anchor" aria-label="anchor" href="#arg-ask-before-hmc"></a></dt>
<dd><p>Logical. If <code>TRUE</code>, ask before running full HMC.</p></dd>


<dt id="arg-block-max">block_max<a class="anchor" aria-label="anchor" href="#arg-block-max"></a></dt>
<dd><p>Integer cap on the size of the block union.</p></dd>


<dt id="arg-slice-control">slice_control<a class="anchor" aria-label="anchor" href="#arg-slice-control"></a></dt>
<dd><p>List of controls passed to <code>"slice"</code> samplers.</p></dd>


<dt id="arg-rw-control">rw_control<a class="anchor" aria-label="anchor" href="#arg-rw-control"></a></dt>
<dd><p>List of controls passed to <code>"RW"</code> samplers.</p></dd>


<dt id="arg-rwblock-control">rwblock_control<a class="anchor" aria-label="anchor" href="#arg-rwblock-control"></a></dt>
<dd><p>List of controls passed to <code>"RW_block"</code> samplers.</p></dd>


<dt id="arg-af-slice-control">af_slice_control<a class="anchor" aria-label="anchor" href="#arg-af-slice-control"></a></dt>
<dd><p>List of controls passed to <code>"AF_slice"</code> samplers.</p></dd>


<dt id="arg-slice-max-contractions">slice_max_contractions<a class="anchor" aria-label="anchor" href="#arg-slice-max-contractions"></a></dt>
<dd><p>Integer safety cap for slice contractions.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>A list with elements such as:</p><dl><dt>status</dt>
<dd><p>Character status string.</p></dd>

<dt>mode</dt>
<dd><p>Character mode (e.g. <code>"HMC_full"</code>, <code>"surgical_*"</code>).</p></dd>

<dt>baseline</dt>
<dd><p>Baseline run info (runtime, samples, diagnostics).</p></dd>

<dt>targets</dt>
<dd><p>Chosen target node names.</p></dd>

<dt>steps</dt>
<dd><p>List of steps; each contains nodes, sampler, results, and directory.</p></dd>


</dl></div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>The procedure:</p><ol><li><p>Build and run a baseline MCMC using <code><a href="run_baseline_config.html">run_baseline_config()</a></code>.</p></li>
<li><p>Optionally run full-model HMC/NUTS via <code><a href="configure_hmc_safely.html">configure_hmc_safely()</a></code>.</p></li>
<li><p>Select <code>nbot</code> bottleneck node(s) from diagnostics (or from
<code>force_singletons</code>), then:</p><ul><li><p>apply <code>strict_scalar_seq</code> in order on the first node;</p></li>
<li><p>if <code>nbot &gt;= 2</code>, build the union <code>{node1, node2}</code>
(or <code>force_union_nodes</code>) and apply <code>strict_block_seq</code>.</p></li>
</ul></li>
<li><p>For each step, compile, run, compute diagnostics, and save plots.</p></li>
</ol><p>When <code>ask = TRUE</code>, interactive yes/no prompts allow you to stop early.</p>
    </div>
    <div class="section level2">
    <h2 id="side-effects">Side effects<a class="anchor" aria-label="anchor" href="#side-effects"></a></h2>


<p>Creates subfolders and PNG files (R-hat bars, traces/densities) under
<code>out_dir</code>. May load/unload compiled DLLs while switching samplers.</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p><code><a href="configure_hmc_safely.html">configure_hmc_safely</a></code>,
<code><a href="plot_convergence_checks.html">plot_convergence_checks</a></code>, <code><a href="plot_bottlenecks.html">plot_bottlenecks</a></code></p></div>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span> <span class="co"># \dontrun{</span></span></span>
<span class="r-in"><span><span class="va">res</span> <span class="op">&lt;-</span> <span class="fu">test_strategy</span><span class="op">(</span></span></span>
<span class="r-in"><span>  build_fn <span class="op">=</span> <span class="va">my_build_fn</span>,</span></span>
<span class="r-in"><span>  monitors <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"theta"</span>,<span class="st">"beta"</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  try_hmc  <span class="op">=</span> <span class="cn">TRUE</span>,</span></span>
<span class="r-in"><span>  nbot     <span class="op">=</span> <span class="fl">2</span>,</span></span>
<span class="r-in"><span>  out_dir  <span class="op">=</span> <span class="st">"outputs/diagnostics"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span> <span class="co"># }</span></span></span>
<span class="r-in"><span><span class="va">test_strategy</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> function (build_fn, monitors = NULL, try_hmc = TRUE, nchains = 3L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pilot_niter = 20000, pilot_burnin = 5000, thin = 1L, out_dir = "outputs/diagnostics", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nbot = 1L, strict_scalar_seq = c("NUTS", "slice", "RW"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     strict_block_seq = c("NUTS_block", "AF_slice", "RW_block"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     force_singletons = NULL, force_union_nodes = NULL, force_union = NULL, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ask = TRUE, ask_before_hmc = TRUE, block_max = 20L, slice_control = list(), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rw_control = list(), rwblock_control = list(adaptScaleOnly = TRUE), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     af_slice_control = list(), slice_max_contractions = 5000L) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     `%||%` &lt;- function(x, y) if (is.null(x)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else x</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     stopifnot(nbot &gt;= 1L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.list(build_fn) &amp;&amp; !is.null(build_fn$model)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         obj &lt;- build_fn</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         build_fn &lt;- function() obj</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     stopifnot(is.function(build_fn))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!requireNamespace("nimble", quietly = TRUE)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         stop("samOptiPro: 'nimble' is required.")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!dir.exists(out_dir)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     say &lt;- function(...) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         msg &lt;- try(sprintf(...), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!inherits(msg, "try-error")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cat(msg, "\n")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     is_ll &lt;- function(x) grepl("^logLik(\\[.*\\])?$|log_?lik|logdens|lpdf", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         x, perl = TRUE, ignore.case = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .sanitize_iters &lt;- local({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         warned &lt;- FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         function(niter, nburnin) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             niter &lt;- as.integer(niter)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             nburnin &lt;- as.integer(nburnin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (is.na(niter) || niter &lt; 1L) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 niter &lt;- 1L</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (is.na(nburnin) || nburnin &lt; 0L) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nburnin &lt;- 0L</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (nburnin &gt;= niter) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 new_nburnin &lt;- max(0L, niter - 1L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (!warned) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   message(sprintf("[info] Adjusting nburnin (%d) to %d because nburnin must be &lt; niter (%d).", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     nburnin, new_nburnin, niter))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   warned &lt;&lt;- TRUE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nburnin &lt;- new_nburnin</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             list(niter = niter, nburnin = nburnin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     })</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .ask_yes_no_strict &lt;- function(prompt) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!isTRUE(ask) || !interactive()) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             return(TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         while (TRUE) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cat(paste0(prompt, " (yes/no): "))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             utils::flush.console()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ans &lt;- try(readline(), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (inherits(ans, "try-error")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 return(TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ans &lt;- tolower(trimws(ans))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (ans %in% c("y", "yes", "o", "oui")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 return(TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (ans %in% c("n", "no", "non")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 return(FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cat("Please answer 'yes' or 'no'.\n")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .barrier_before_block &lt;- function(tag = "scalar_to_block") {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         try(nimble::clearCompiled(), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         gc()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         new_bd &lt;- file.path(tempdir(), paste0("samOptiPro_build_", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             gsub("[^A-Za-z0-9_]+", "_", tag), "_", as.integer(stats::runif(1, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 1e+09, 9e+09))))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         dir.create(new_bd, recursive = TRUE, showWarnings = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         assign(".sop_old_builddir", nimble::nimbleOptions("buildDir"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             inherits = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nimble::nimbleOptions(buildDir = new_bd)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (.Platform$OS.type == "windows") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             Sys.sleep(0.3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else Sys.sleep(0.05)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         invisible(TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .restore_builddir &lt;- function() {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         old &lt;- try(get(".sop_old_builddir", inherits = FALSE), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!inherits(old, "try-error") &amp;&amp; !is.null(old)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             try(nimble::nimbleOptions(buildDir = old), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         invisible(TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .ensure_unsampled &lt;- function(conf) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         uns &lt;- try(conf$getUnsampledNodes(), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!inherits(uns, "try-error") &amp;&amp; length(uns)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             uns &lt;- uns[!is_ll(uns)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             for (u in uns) conf$addSampler(u, type = "slice")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .compile_and_run &lt;- function(step_tag, build_obj, conf, niter, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nburnin) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         it &lt;- .sanitize_iters(niter, nburnin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         niter &lt;- it$niter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nburnin &lt;- it$nburnin</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         attempts &lt;- 0L</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         last_err &lt;- NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         repeat {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             attempts &lt;- attempts + 1L</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             try(nimble::clearCompiled(), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             gc()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             res &lt;- try({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 .ensure_unsampled(conf)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 cmcmc &lt;- .compile_mcmc_with_build(conf, build_obj, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   reset = TRUE, show = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 out &lt;- .run_and_collect(cmcmc, niter = niter, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   nburnin = nburnin, thin = thin, nchains = nchains)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ml &lt;- as_mcmc_list_sop(out$samples, out$samples2, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   drop_loglik = FALSE, thin = thin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 dg &lt;- compute_diag_from_mcmc(ml, runtime_s = out$runtime_s)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (!is.null(cmcmc) &amp;&amp; is.list(cmcmc) &amp;&amp; "unloadDLL" %in% </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   names(cmcmc)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   try(cmcmc$unloadDLL(), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 list(out = out, ml = ml, dg = dg)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }, silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (!inherits(res, "try-error")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 return(res)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             last_err &lt;- tryCatch(conditionMessage(attr(res, "condition")), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 error = function(e) as.character(res))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (attempts == 1L) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 message(sprintf("[info] First attempt failed at %s; retrying cleanly...", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   step_tag))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else message(sprintf("[retry %d @ %s] %s", attempts, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 step_tag, last_err))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             build_obj &lt;- .fresh_build(build_fn, monitors = monitors, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 thin = thin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             conf &lt;- build_obj$conf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (attempts &gt;= 3L) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stop(sprintf("Compilation failed after %d attempts at step '%s': %s", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   attempts, step_tag, last_err))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .add_scalar &lt;- function(conf, nodes, type, has_hmc) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (identical(type, "NUTS")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (isTRUE(has_hmc)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 for (n in nodes) conf$addSampler(target = n, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   type = "NUTS")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 cat("[Info] nimbleHMC not available -&gt; falling back to slice (scalar).\n")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 for (n in nodes) conf$addSampler(n, "slice", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   slice_control)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             return(invisible())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (identical(type, "slice")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             for (n in nodes) conf$addSampler(n, "slice", slice_control)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             return(invisible())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (identical(type, "RW")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             for (n in nodes) conf$addSampler(n, "RW", rw_control)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             return(invisible())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (n in nodes) conf$addSampler(n, "slice", slice_control)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .add_block &lt;- function(conf, nodes, type, has_hmc, Sc = NULL) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nodes &lt;- unique(nodes)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (length(nodes) &lt; 2L) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (type == "NUTS_block") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 .add_scalar(conf, nodes, "NUTS", has_hmc)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else if (type == "AF_slice") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 for (n in nodes) conf$addSampler(n, "AF_slice", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   af_slice_control)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else if (type == "RW_block") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 for (n in nodes) conf$addSampler(n, "RW", rw_control)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else for (n in nodes) conf$addSampler(n, "slice", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 slice_control)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             return(invisible())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (identical(type, "NUTS_block")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (isTRUE(has_hmc)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 conf$addSampler(target = nodes, type = "NUTS")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 cat("[Info] nimbleHMC not available -&gt; falling back to AF_slice (block).\n")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 conf$addSampler(target = nodes, type = "AF_slice", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   control = af_slice_control)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             return(invisible())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (identical(type, "AF_slice")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ok &lt;- TRUE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tryCatch({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 conf$addSampler(target = nodes, type = "AF_slice", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   control = af_slice_control)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }, error = function(e) ok &lt;&lt;- FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (!ok) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 for (n in nodes) conf$addSampler(n, "slice", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   slice_control)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             return(invisible())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (identical(type, "RW_block")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ctrl &lt;- rwblock_control</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (!is.null(Sc)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ctrl$propCov &lt;- Sc</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             conf$addSampler(nodes, "RW_block", ctrl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             return(invisible())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (n in nodes) conf$addSampler(n, "slice", slice_control)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .metrics_for &lt;- function(dg, nodes) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nodes &lt;- nodes[!is.na(nodes) &amp; nzchar(nodes)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         keep &lt;- dg$target %in% nodes &amp; !is_ll(dg$target)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         list(AE = stats::median(dg$AE_ESS_per_it[keep], na.rm = TRUE), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             CE = stats::median(dg$ESS_per_sec[keep], na.rm = TRUE), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             Rhat = if (any(keep)) suppressWarnings(max(dg$Rhat[keep], </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 na.rm = TRUE)) else NA_real_)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .print_step &lt;- function(title, label, nodes, sampler, runtime, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         met, base_dx, base_rt) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nodes &lt;- nodes[!is.na(nodes) &amp; nzchar(nodes)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         say("--- %s ---", title)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!is.null(label)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             say("Target(s): %s", label)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         say("Nodes: %s", paste(nodes, collapse = ", "))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         say("Sampler: %s", sampler)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         say("Runtime_s: %.2f (baseline: %.2f)", runtime %||% </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             NA_real_, base_rt %||% NA_real_)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         say("AE median (ESS/iter): %.3g (baseline: %.3g)", met$AE %||% </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             NA_real_, stats::median(base_dx$AE_ESS_per_it, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         say("CE median (ESS/s):    %.3g (baseline: %.3g)", met$CE %||% </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             NA_real_, stats::median(base_dx$ESS_per_sec, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         say("Rhat max:             %.3g (baseline max: %.3g)", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             met$Rhat %||% NA_real_, suppressWarnings(max(base_dx$Rhat, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     b0 &lt;- .fresh_build(build_fn, monitors = monitors, thin = thin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mdl &lt;- b0$model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     it &lt;- .sanitize_iters(pilot_niter, pilot_burnin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     rb &lt;- run_baseline_config(build_fn, it$niter, it$nburnin, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         thin, monitors, nchains)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     base_ml &lt;- as_mcmc_list_sop(rb$samples, rb$samples2, drop_loglik = FALSE, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         thin = thin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     base_dg &lt;- compute_diag_from_mcmc(base_ml, runtime_s = rb$runtime_s)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     base_dx &lt;- base_dg[!is_ll(base_dg$target), , drop = FALSE]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     say("Baseline runtime_s: %.2f s", rb$runtime_s %||% NA_real_)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     say("Baseline median AE(ESS/iter): %.3g", stats::median(base_dx$AE_ESS_per_it, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     say("Baseline median CE(ESS/s):    %.3g", stats::median(base_dx$ESS_per_sec, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     dg_struct &lt;- try(diagnose_model_structure(mdl), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     suppressWarnings(has_hmc &lt;- requireNamespace("nimbleHMC", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         quietly = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     deriv_ok &lt;- .sop_supports_derivs(mdl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     blockers &lt;- character(0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!inherits(dg_struct, "try-error") &amp;&amp; !is.null(dg_struct)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (isTRUE(dg_struct$has_truncation)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             blockers &lt;- c(blockers, "truncation")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (isTRUE(dg_struct$has_simplex)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             blockers &lt;- c(blockers, "simplex-constraint")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (isTRUE(dg_struct$has_non_diff_fun)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             blockers &lt;- c(blockers, "non-diff-function")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nuts_ok_global &lt;- isTRUE(try_hmc) &amp;&amp; has_hmc &amp;&amp; deriv_ok &amp;&amp; </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         (length(blockers) == 0L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (isTRUE(nuts_ok_global)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (.ask_yes_no_strict(sprintf("Baseline ready. Runtime=%.2fs; median AE=%.3g; median CE=%.3g\nProceed with full-model HMC/NUTS?", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             rb$runtime_s %||% NA_real_, median(base_dx$AE_ESS_per_it, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 na.rm = TRUE), median(base_dx$ESS_per_sec, na.rm = TRUE)))) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             hmc_try &lt;- configure_hmc_safely(build_fn = build_fn, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 niter = it$niter, nburnin = it$nburnin, thin = thin, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 monitors = monitors, nchains = nchains, out_dir = file.path(out_dir, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   "HMC_full"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (isTRUE(hmc_try$ok)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 dg &lt;- hmc_try$diag_tbl</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 cat(sprintf("HMC runtime_s: %.3f\n", hmc_try$res$runtime_s %||% </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   NA_real_))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 cat(sprintf("HMC median AE: %.3g ; CE: %.3g ; max Rhat: %.3g\n", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   median(dg$AE_ESS_per_it, na.rm = TRUE), median(dg$ESS_per_sec, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     na.rm = TRUE), if (all(is.na(dg$Rhat))) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     NA_real_</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   else max(dg$Rhat, na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 return(list(mode = "HMC_full", baseline = list(runtime_s = rb$runtime_s, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   samples = base_ml, diag_tbl = base_dg), hmc = hmc_try, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   messages = "Full HMC completed."))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 cat("[Warn] Full-model HMC failed -&gt; continuing with surgical singleton plan.\n")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cat("User declined full-model HMC/NUTS. Switching to surgical singleton plan.\n")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     stoch_nodes &lt;- mdl$getNodeNames(stochOnly = TRUE, includeData = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     stoch_nodes &lt;- stoch_nodes[!is_ll(stoch_nodes)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.null(force_union_nodes) &amp;&amp; !is.null(force_union)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         force_union_nodes &lt;- force_union</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     pick_nodes &lt;- character(0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(force_singletons) &amp;&amp; length(force_singletons)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pn &lt;- unique(force_singletons)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         present &lt;- intersect(pn, intersect(stoch_nodes, unique(colnames(as.matrix(base_ml[[1]])))))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pick_nodes &lt;- utils::head(present, nbot)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!length(pick_nodes)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         node_like &lt;- grepl("\\[", base_dx$target)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (any(node_like)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ord &lt;- order(base_dx$ESS_per_sec[node_like], decreasing = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cand &lt;- base_dx$target[node_like][ord]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             pick_nodes &lt;- intersect(utils::head(cand, nbot), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stoch_nodes)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!length(pick_nodes)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!requireNamespace("coda", quietly = TRUE)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stop("samOptiPro: 'coda' package required for node-level ESS.")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         common_cols &lt;- Reduce(intersect, lapply(base_ml, function(m) colnames(as.matrix(m))))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         node_cols &lt;- intersect(common_cols, stoch_nodes)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (length(node_cols)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ess_per_node &lt;- sapply(node_cols, function(nm) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ess_ch &lt;- sapply(base_ml, function(m) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   X &lt;- as.matrix(m)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   if (nm %in% colnames(X)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     coda::effectiveSize(X[, nm])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   else NA_real_</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 })</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 sum(ess_ch, na.rm = TRUE)/(rb$runtime_s %||% </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ord &lt;- order(ess_per_node, decreasing = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             pick_nodes &lt;- utils::head(names(ess_per_node)[ord], </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nbot)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             pick_nodes &lt;- pick_nodes[!is.na(pick_nodes)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!length(pick_nodes)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         present &lt;- intersect(stoch_nodes, unique(colnames(as.matrix(base_ml[[1]]))))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pick_nodes &lt;- utils::head(present, nbot)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!length(pick_nodes)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         stop("No stochastic singleton targets to operate on.")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     say("Selected singleton bottlenecks (nbot=%d): %s", length(pick_nodes), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         paste(pick_nodes, collapse = ", "))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     steps &lt;- list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (nbot == 1L) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         node1 &lt;- pick_nodes[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (samp in unique(as.character(strict_scalar_seq))) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             bS &lt;- .fresh_build(build_fn, monitors = monitors, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 thin = thin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             confS &lt;- bS$conf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             try(confS$removeSamplers(node1), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .add_scalar(confS, node1, samp, has_hmc)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             itS &lt;- .sanitize_iters(pilot_niter, pilot_burnin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             resS &lt;- .compile_and_run(paste0("nbot1_", gsub("[^A-Za-z0-9_]+", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "_", node1), "_", samp), bS, confS, itS$niter, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 itS$nburnin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             metS &lt;- .metrics_for(resS$dg, node1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .print_step("Scalar plan on singleton", node1, node1, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 samp, resS$out$runtime_s, metS, base_dx, rb$runtime_s)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             pdir &lt;- file.path(out_dir, sprintf("singleton_%s_%s", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 gsub("[^A-Za-z0-9_]", "_", node1), samp))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (!dir.exists(pdir)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 dir.create(pdir, recursive = TRUE, showWarnings = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .plot_rhat_bar(resS$dg, nodes = node1, out_file = file.path(pdir, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "rhat_bar.png"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .plot_traces(resS$ml, nodes = node1, out_file_prefix = file.path(pdir, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "trace_"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             steps &lt;- c(steps, list(list(level = "singleton-scalar", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nodes = node1, sampler = samp, res = resS, dir = pdir)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (!.ask_yes_no_strict(sprintf("Proceed to the next sampler for '%s'?", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 node1))) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 break</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         return(list(status = "completed", mode = "surgical_nbot1_singleton", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             baseline = rb, targets = pick_nodes, steps = steps))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     node1 &lt;- pick_nodes[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (samp in unique(as.character(strict_scalar_seq))) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         bS &lt;- .fresh_build(build_fn, monitors = monitors, thin = thin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         confS &lt;- bS$conf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         try(confS$removeSamplers(node1), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         .add_scalar(confS, node1, samp, has_hmc)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         itS &lt;- .sanitize_iters(pilot_niter, pilot_burnin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         resS &lt;- .compile_and_run(paste0("nbot2_scalar_", gsub("[^A-Za-z0-9_]+", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             "_", node1), "_", samp), bS, confS, itS$niter, itS$nburnin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         metS &lt;- .metrics_for(resS$dg, node1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         .print_step("Scalar plan on singleton", node1, node1, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             samp, resS$out$runtime_s, metS, base_dx, rb$runtime_s)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pdir &lt;- file.path(out_dir, sprintf("singleton_%s_%s", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             gsub("[^A-Za-z0-9_]", "_", node1), samp))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!dir.exists(pdir)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             dir.create(pdir, recursive = TRUE, showWarnings = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         .plot_rhat_bar(resS$dg, nodes = node1, out_file = file.path(pdir, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             "rhat_bar.png"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         .plot_traces(resS$ml, nodes = node1, out_file_prefix = file.path(pdir, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             "trace_"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         steps &lt;- c(steps, list(list(level = "singleton-scalar", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             nodes = node1, sampler = samp, res = resS, dir = pdir)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!.ask_yes_no_strict(sprintf("Proceed to the next sampler for '%s'?", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             node1))) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             break</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     node2 &lt;- pick_nodes[2] %||% NA_character_</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     union_nodes &lt;- if (!is.null(force_union_nodes) &amp;&amp; length(force_union_nodes) &gt;= </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         2L) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         present &lt;- intersect(unique(force_union_nodes), intersect(mdl$getNodeNames(stochOnly = TRUE, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             includeData = FALSE), unique(colnames(as.matrix(base_ml[[1]])))))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         unique(present)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else unique(c(node1, node2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     union_nodes &lt;- union_nodes[!is.na(union_nodes) &amp; nzchar(union_nodes)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     union_nodes &lt;- unique(union_nodes)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (length(union_nodes) &gt; block_max) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         union_nodes &lt;- utils::head(union_nodes, block_max)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (length(union_nodes) &lt; 2L) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         message(sprintf("[info] Skipping block phase: need at least 2 valid nodes, got %d (%s).", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             length(union_nodes), paste(union_nodes, collapse = ", ")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         return(list(status = "completed", mode = "surgical_nbot2_singleton_no_block", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             baseline = rb, targets = pick_nodes, steps = steps))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .barrier_before_block("scalar_to_block_singletons")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     on.exit(.restore_builddir(), add = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     propCov &lt;- NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     M_full &lt;- do.call(rbind, lapply(base_ml, function(m) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         X &lt;- as.matrix(m)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         keep &lt;- intersect(colnames(X), union_nodes)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         X[, keep, drop = FALSE]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(M_full) &amp;&amp; is.matrix(M_full) &amp;&amp; ncol(M_full) &gt;= </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         2L) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         S &lt;- try(stats::cov(M_full, use = "pairwise.complete.obs"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!inherits(S, "try-error")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             pc &lt;- try(.sop_make_propCov_PD(S), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (!inherits(pc, "try-error")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 propCov &lt;- pc</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (samp in unique(as.character(strict_block_seq))) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         bB &lt;- .fresh_build(build_fn, monitors = monitors, thin = thin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         confB &lt;- bB$conf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (n in union_nodes) try(confB$removeSamplers(n), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         .add_block(confB, union_nodes, samp, has_hmc, Sc = propCov)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         itB &lt;- .sanitize_iters(pilot_niter, pilot_burnin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         resB &lt;- .compile_and_run(paste0("nbot2_block_", paste(gsub("[^A-Za-z0-9_]+", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             "_", union_nodes), collapse = "_"), "_", samp), bB, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             confB, itB$niter, itB$nburnin)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         metB &lt;- .metrics_for(resB$dg, union_nodes)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         .print_step("Block plan on union (singletons)", paste(union_nodes, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             collapse = " + "), union_nodes, samp, resB$out$runtime_s, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             metB, base_dx, rb$runtime_s)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pdir &lt;- file.path(out_dir, sprintf("block_union_singletons_%s", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             paste(gsub("[^A-Za-z0-9_]+", "_", union_nodes), collapse = "_")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!dir.exists(pdir)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             dir.create(pdir, recursive = TRUE, showWarnings = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         .plot_rhat_bar(resB$dg, nodes = union_nodes, out_file = file.path(pdir, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             "rhat_bar.png"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         .plot_traces(resB$ml, nodes = union_nodes, out_file_prefix = file.path(pdir, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             "trace_"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         steps &lt;- c(steps, list(list(level = "singletons-block", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             nodes = union_nodes, sampler = samp, res = resB, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             dir = pdir)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!.ask_yes_no_strict("Proceed to the next BLOCK sampler for the union?")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             break</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return(list(status = "completed", mode = "surgical_nbot2_singleton", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         baseline = rb, targets = pick_nodes, steps = steps))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> &lt;bytecode: 0x55c0af813110&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> &lt;environment: namespace:samOptiPro&gt;</span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Romuald Hounyeme, Etienne Rivot.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer></div>





  </body></html>

